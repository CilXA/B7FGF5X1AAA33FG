local exec = identifyexecutor()
local version = "v0.0.4a"

local detectedAdmins = {}

local Decimals = 4
local Clock = os.clock()

local library = loadstring(game:HttpGet("https://raw.githubusercontent.com/CilXA/B7FGF5X1AAA33FG/refs/heads/main/newlibtest"))({
    cheatname = "Exothium.xyz", -- watermark text
    gamename = "Project Delta", -- watermark text
})

library:init()

local Window1  = library.NewWindow({
    title = "Exothium.xyz - " .. version,
    size = UDim2.new(0, 510, 0.66, 5
)})

local combat = Window1:AddTab('Combat')
local playerstab = Window1:AddTab("Player")
local visualstab = Window1:AddTab("Visuals")
local other = Window1:AddTab("Misc")
local settings = library:CreateSettingsTab(Window1)

function getcurrentgun(plr)
    local char = plr.Character
    if not char then return nil, nil end
    local invchar = game.ReplicatedStorage.Players:FindFirstChild(game.Players.LocalPlayer.Name).Inventory
    if not invchar then return nil, nil end

    local gun = nil
    local gunname = nil
    local guninv = nil

    for _, desc in ipairs(char:GetDescendants()) do
        if desc:IsA("Model") and desc:FindFirstChild("ItemRoot") and desc:FindFirstChild("Attachments") then
            gun = desc
            gunname = desc.Name
            guninv = invchar:FindFirstChild(gunname)
        end
    end

    return gunname, gun, guninv
end
function getcurrentammo(gun)
    if gun == nil then return nil end
    local loadedfold = gun:FindFirstChild("LoadedAmmo", true)
    if not loadedfold then return nil end
    local firstammo = loadedfold["1"]
    if not firstammo then return nil end

    local ammoname = firstammo:GetAttribute("AmmoType")
    local ammo = game.ReplicatedStorage.AmmoTypes:FindFirstChild(ammoname)
    if not ammo then return nil end

    return ammo
end

if game.Players.LocalPlayer.Character == nil or not game.Players.LocalPlayer.Character:FindFirstChild("Humanoid") then
    library:SendNotification(("Character is missing, script will load when spawned in"), 10)
    
    while game.Players.LocalPlayer.Character == nil or not game.Players.LocalPlayer.Character:FindFirstChild("Humanoid") do
        wait(0.2)
    end
end

wait(0.5)

local libraryxxt = pcall(function()
    local drawing199 = Drawing.new("Square")
    drawing199.Visible = false
    drawing199:Destroy()
end)

if libraryxxt == false then
    library:SendNotification(("DL-F"), 0.6)
    loadstring(game:HttpGet("https://raw.githubusercontent.com/CilXA/B7FGF5X1AAA33FG/refs/heads/main/Drawing"))()
    library:SendNotification(("DL-T"), 0.3)
end

if string.match(exec, "Wave") == nil and string.match(exec, "Synapse") == nil and string.match(exec, "Seliware") == nil and string.match(exec, "Nihon") == nil and string.match(exec, "AWP") == nil and string.match(exec, "Swift") == nil then
    library:SendNotification((exec .. "is not supported"), 10)
    return
else
    library:SendNotification(("Loading Assets " .. version .. " - " .. exec), 4)
    print("[[ Exoguard V3 || Exothium.xyz || " .. exec .." || " .. version .. " ]]")
end
if exec == "Seliware" or exec == "Nihon" then
    library:SendNotification((exec .. " is semi-supported, script might cause errors."), 3.5)
end
if _G.exothiumxyz then
    library:SendNotification(("Script is already loaded, therefore you cant execute it again"), 3.5)
    return
end

_G.exothiumxyz = true

local wcamera = workspace.CurrentCamera
local Players = game:GetService("Players")
local localplayer = game.Players.LocalPlayer
local runs = game:GetService("RunService")
local rp = game:GetService("ReplicatedStorage")
local aiZones = workspace:FindFirstChild("AiZones")
local whisperZone = aiZones and aiZones:FindFirstChild("Whisper")
local stg = localplayer:WaitForChild("PlayerGui")
local sg = stg:FindFirstChild("Exothium.xyz") or Instance.new("ScreenGui", stg); sg.Name = "Exothium.xyz"; sg.IgnoreGuiInset = true ;sg.ResetOnSpawn = false
local uis = game:GetService("UserInputService")
local realAmmoTypes = rp:FindFirstChild("realAmmoTypes") or rp:FindFirstChild("AmmoTypes") and rp:FindFirstChild("AmmoTypes"):Clone(); if realAmmoTypes then realAmmoTypes.Name = "realAmmoTypes" end
local mouse = localplayer:GetMouse()

local aimbool = false
local aimdebug1 = false
local aimdebug2 = false
local aimdebug3 = false
local aimselftrack = false
local aimbots = false
local aimvischeck = false
local aimdistcheck = false
local aimbang = true
local aimtrigger = false
local aiminfrange = false
local aimtarget = nil
local aimtargetpart = nil
local aimdynamicfov = false
local aimpart = "Head"
local aimtype = "Instant Hit"
local aimfov = 150
local aimdistance = 1500
local aimchance = 100
local aimfakewait = 0
local aimsnapline = Drawing.new("Line")
local snaplinebool = false
local aimfovcircle = Drawing.new("Circle")
local aimtargetname = Drawing.new("Text")
local aimogfunc = require(game.ReplicatedStorage.Modules.FPS.Bullet).CreateBullet
local aimmodfunc
local aimignoreparts = {}
for i,v in ipairs(workspace:GetDescendants()) do
    if v:GetAttribute("PassThrough") then
        table.insert(aimignoreparts, v)
    end
end

local selftrack_data = {}
local selftrack_update = 0

local debuglist95 = {}
local debuglistmode24 = "Blacklist"
local debuglistmode95x = false

local esptextcolor = Color3.fromRGB(77, 210, 255)
local esptable = {}
--[[ esptable template
    drawingobj = {
        primary = instance
        type = string --(highlight, name, hp, hotbar, distance, skelet)
        otype = string --(plr, bot, dead, extract, loot)
        fpart = instance --(for skelet)
        spart = instance --(for skelet)
    }      
]] 

healthtargetname = false
admintargetname = false

espbool = false -- main toggle for everything if this is false and everything else is true nothing will show, if this is true and everything is on it will show everything
esptogglebind = Enum.KeyCode.Home -- espbind (dont change)
espname = false -- esp name toggle
esphp = false -- esp health toggle
espdistance = false -- esp distance toggle
espbots = false -- include bots in esp
esphigh = false -- this is higghlight (chams)
espskelet = false -- u can get rid of this
espdead = false -- dead body esp
esphotbar = false -- whatever the player is holding
esploot = false -- u can get rid of this
espexit = false -- esp for exits, make a variable where it will say exitzones folder path
esptextline = true -- text outline
esprenderdist = 1800 -- render distance for esp
espchamsfill = 1    --highlight (for chams)
espchamsline = 0    --highlight (for chams)
esptextsize = 17    -- for drawing text
espfillcolor = Color3.fromRGB(77, 210, 255) --highlight (for chams)
esplinecolor = Color3.fromRGB(77, 210, 255) --highlight (for chams)

silentaimbind = Enum.KeyCode.H
autoshootbind = Enum.KeyCode.K

inventoryCheckerToggle = true
inventoryCheckerBind = Enum.KeyCode.Backquote

tracbool = false
tracwait = 1
traccolor = Color3.fromRGB(77, 210, 255)

tracbool = false
tracwait = 1
traccolor = Color3.fromRGB(77, 210, 255)
tracertexture = nil
local tracertextures = {
    ["None"] = nil,
    ["Neon"] = "http://www.roblox.com/asset/?id=71799812889976",
    ["Lightning"] = "http://www.roblox.com/asset/?id=7151778311",
    ["Wide"] = "http://www.roblox.com/asset/?id=75056325012653"
}

local crosshair = Drawing.new("Circle")

local defaultfirerate = {}

local createdThings = {}

local viewmod_materials = {
    ["Forcefield"] = Enum.Material.ForceField,
    ["Neon"] = Enum.Material.Neon,
    ["Plastic"] = Enum.Material.SmoothPlastic
}
viewmodbool = false
viewmodhandmat = Enum.Material.ForceField
viewmodgunmat = Enum.Material.ForceField
viewmodhandcolor = Color3.fromRGB(77, 210, 255)
viewmodguncolor = Color3.fromRGB(77, 210, 255)
viewmodX = 0.2
viewmodY = -2
viewmodZ = -0.32

viewmodhighlightchams = false

viewmodhighlightfillcolor = Color3.fromRGB(77, 210, 255)
viewmodhighlightoutlinecolor = Color3.fromRGB(77, 210, 255)

viewmodhighlightfilltransparency = 1
viewmodhighlightoutlinetransparency = 0

local speedbool = false
local speedboost = 1.2

local changerbool = false
local changergrav = 95
local changerspeed = 18
local changerheight = 2
local changerjump = 4

local charsemiflybind = Enum.KeyCode.X
local charsemifly = false
local charsemiflydist = 6
local charsemiflydistunlock = false
local charsemiflyspeed = 18
local semifly_bodyvel = nil

whisperNotificationToggle = false
notifiedwhisper = false

bunnyhop = false

worldleaves = false
worldclock = 14

local waterplatforms = Instance.new("Folder", workspace)
waterplatforms.Name = "WaterPlatforms"
local worldjesus

local worldvisualstoggle = false
local worldambient = Color3.fromRGB(255,255,255)
local worldoutdoor = Color3.fromRGB(255,255,255)

charantiaim_underground = false

flipback = false

upangletoggle = false
upangleY = 0 -- 0.03070496954023838

xspeedspin = 0
xspinning = false -- xrot spin

yspeedspin = 0
yspinning = false -- yrot spin

zspeedspin = 0
zspinning = false -- zrot spin

xrot = 0
yrot = 0
zrot = 0

resolver = false

local hitsoundbool = false
local hitsoundhead = "Neverlose"
local hitsoundbody = "Gamesense"
local hitsoundlib = {
    ["Neverlose"] = "rbxassetid://8726881116",
    ["Gamesense"] = "rbxassetid://4817809188",
    ["Rust"]      = "rbxassetid://1255040462",
    ["Bubble"]    = "rbxassetid://198598793",
    ["Minecraft"] = "rbxassetid://6361963422",
    ["Among-Us"]  = "rbxassetid://7227567562",
}
local hitsoundlibUI = {}
for i,v in hitsoundlib do
    hitsoundlibUI[v] = i
end

NoRecoil = false
BulletTracer = false
InstaReload = true
GunDrag = false
NoProjectileDrop = false
RapidFire = false
NoSway = false
InstaEquip = false
UnlockFiremodes = false
BurstFire = 1

AntiDrown = false
AntiProjectile = true

NoFallDamage = false
transparencyToggle = false

local valcache = {
    ["6B45"] = 16,
    ["AS Val"] = 16,
    ["ATC Key"] = 6,
    ["Airfield Key"] = 6,
    ["Altyn"] = 16,
    ["Altyn Visor"] = 8,
    ["Maska Visor"] = 8,
    ["Attak-5 60L"] = 16,
    ["Bolts"] = 1,
    ["Crane Key"] = 6,
    ["DAGR"] = 12,
    ["Duct Tape"] = 1,
    ["Fast MT"] = 10,
    ["Flare Gun"] = 20,
    ["Fueling Station Key"] = 2,
    ["Garage Key"] = 4,
    ["Hammer"] = 1,
    ["JPC"] = 10,
    ["Lighthouse Key"] = 6,
    ["M4A1"] = 12,
    ["Nails"] = 1,
    ["Nuts"] = 1,
    ["Saiga 12"] = 8,
    ["Super Glue"] = 1,
    ["Village Key"] = 2,
    ["Wrench"] = 1,
    ["SPSh-44"] = 12,
    ["R700"] = 16,
    ["AKMN"] = 12,
    ["Mosin"] = 12,
    ["SVD"] = 12,
    ["7.62x39AP"] = 0.15,
    ["7.62x54AP"] = 0,15,
}

--drawing setup--

aimfovcircle.Visible = false
aimfovcircle.Radius = aimfov
aimfovcircle.Thickness = 1
aimfovcircle.Filled = false
aimfovcircle.Transparency = 1
aimfovcircle.Color = Color3.fromRGB(77, 210, 255)
aimfovcircle.Position = Vector2.new(wcamera.ViewportSize.X / 2, wcamera.ViewportSize.Y / 2)
crosshair.Visible = false
crosshair.Radius = 2
crosshair.Thickness = 1
crosshair.Filled = true
crosshair.Transparency = 1
crosshair.Color = Color3.fromRGB(77, 210, 255)
crosshair.Position = Vector2.new(wcamera.ViewportSize.X / 2, wcamera.ViewportSize.Y / 2)
aimtargetname.Text = " "
aimtargetname.Position = Vector2.new(wcamera.ViewportSize.X / 2, wcamera.ViewportSize.Y / 2 + aimfov + 20) 
aimtargetname.Size = 20
aimtargetname.Color = Color3.fromRGB(77, 210, 255)
aimtargetname.Visible = false
aimtargetname.Center = true
aimtargetname.Outline = true
aimsnapline.From = Vector2.new(20, 20)
aimsnapline.To = Vector2.new(50, 50)
aimsnapline.Color = Color3.fromRGB(77, 210, 255)
aimsnapline.Thickness = 1
aimsnapline.Visible = false

if not getrawmetatable or not setreadonly then
    warn("Error: 426 getrawmetatable is not a available function")
    return
end

local mt = getrawmetatable(game)
local oldNamecall = mt.__namecall
setreadonly(mt, false)

mt.__namecall = newcclosure(function(self, ...)
    local Method = getnamecallmethod()
    local Args = {...}

    if Method == "FireServer" and self.Name == "Drowning" and AntiDrown then
        return
    end

    if Method == "FireServer" and self.Name == "ProjectileInflict" and AntiProjectile then
        if Args[1] == game.Players.LocalPlayer.Character.HumanoidRootPart then
            return coroutine.yield()
        end
    end

    return oldNamecall(self, ...)
end)

setreadonly(mt, true)

--combat:SetText("Text")

local aim = combat:AddSection("Aimbot", 1)
local gunmods = combat:AddSection("Gun Manipulation", 2)
local tarinfo = combat:AddSection("Target Info", 2)
local snapline = combat:AddSection("Snapline", 1)

local semifly = playerstab:AddSection("Character Modifier", 1)
local privatefeatures = playerstab:AddSection("Player Exploits", 2)

local wh = visualstab:AddSection("Extra-Sensory Perception", 1)
local tracers = visualstab:AddSection("Bullet Tracers", 2)
local cross = visualstab:AddSection("Crosshair", 2)
local worldh = visualstab:AddSection("World", 2)
local viewmod = visualstab:AddSection("Viewmodel", 1)

local camzoom = other:AddSection("Zoom", 1)
local inventorychecker = other:AddSection("Inventory Checker", 2)
local camer = other:AddSection("Effects", 1)
local hitsounds = other:AddSection("Hitsounds", 2)
local extrafeatures = other:AddSection("Extra Features", 2)

--aim:SetText("Text")

extrafeatures:AddButton({
    enabled = true,
    text = "Unlock Boss",
    tooltip = "Unlocks the Boss Trader (NPC)",
    confirm = false,
    risky = false,
    callback = function()
            local npc = game.Workspace.Boss
    npc:SetAttribute("Hidden", false)

    for _, part in pairs(npc:GetChildren()) do
        if part:IsA("BasePart") and part.Name ~= "HumanoidRootPart" then
            part.Transparency = 0
        end
    end
    end
})

extrafeatures:AddButton({
    enabled = true,
    text = "Spawn UAZ",
    tooltip = "Spawns a vehicle",
    confirm = false,
    risky = false,
    callback = function()
        local player = game.Players.LocalPlayer
local plr = player

if not plr.Character or not plr.Character:FindFirstChildOfClass("Humanoid") then 
    return library:SendNotification(("Error: No character detected."), 3)
end

local uaz, dist = nil, math.huge
for i, v in pairs(workspace:WaitForChild("Vehicles"):GetChildren()) do
    if v:FindFirstChild("Body") and v.Body:FindFirstChildOfClass("MeshPart") then
        local vehiclePos = v.Body:FindFirstChildOfClass("MeshPart").Position
        local camPos = workspace.CurrentCamera.CFrame.p
        local distance = (vehiclePos - camPos).Magnitude
        if dist > distance then
            dist = distance
            uaz = v
        end
    end
end

if not uaz then 
    return library:SendNotification(("Error: No car found."), 8)
end

local humanoid = plr.Character:FindFirstChildOfClass("Humanoid")
if humanoid then
    for i, v in ipairs(uaz:GetDescendants()) do
        if v:IsA('Seat') and v.Name == 'SeatFR' then
            v:Sit(humanoid)
        end
    end
end

wait(0.2)

for i = 1, 2 do
    game:GetService("ReplicatedStorage").Remotes.VehicleInteractions:FireServer({
        ["Vehicle"] = uaz,
        ["Action"] = "Enter",
        ["Door"] = uaz.Body.FRdoor.FR_Door
    })
    wait(0.2)
end

uaz.Remotes.ExitSeat:FireServer()
wait(0.1)

game:GetService("ReplicatedStorage").Remotes.VehicleInteractions:FireServer({
    ["Vehicle"] = uaz,
    ["Action"] = "Exit",
    ["Door"] = uaz.Body.FRdoor.FR_Door
})

uaz.Remotes.ExitSeat:FireServer()
wait(1)

player.Character:FindFirstChildOfClass('Humanoid'):Move(Vector3.new(0, 10, 0))
library:SendNotification(("Spawned UAZ."), 5)

    end
})

extrafeatures:AddButton({
    enabled = true,
    text = "Quick Use",
    tooltip = "Quickly uses a item without the animation",
    confirm = false,
    risky = false,
    callback = function()
        game:GetService("ReplicatedStorage"):WaitForChild("Remotes"):WaitForChild("Consume"):FireServer()
    end
})

extrafeatures:AddButton({
    enabled = true,
    text = "Reset",
    tooltip = "Resets your character",
    confirm = true,
    risky = false,
    callback = function()
        game.Players.LocalPlayer.Character.Health.Drowning:FireServer(115)
    end
})

aim:AddToggle({
    text = "Silent Aim",
    state = false,
    risky = true,
    tooltip = "Enables silent aim",
    flag = "SilentAim",
    callback = function(v)
        aimbool = v
        if v == true then
            require(game.ReplicatedStorage.Modules.FPS.Bullet).CreateBullet = aimmodfunc
        else
            require(game.ReplicatedStorage.Modules.FPS.Bullet).CreateBullet = aimogfunc
        end
    end
}):AddBind({
    enabled = true,
    text = "Silent Aim",
    tooltip = "Silent Aim Keybind",
    mode = "toggle",
    bind = "None",
    flag = "ToggleKey_1",
    state = false,
    nomouse = false,
    risky = false,
    noindicator = false,
    callback = function(v)
        aimbool = v
        if v == true then
            require(game.ReplicatedStorage.Modules.FPS.Bullet).CreateBullet = aimmodfunc
        else
            require(game.ReplicatedStorage.Modules.FPS.Bullet).CreateBullet = aimogfunc
        end
    end,
    keycallback = function(v)
        aimbool = v
        if v == true then
            require(game.ReplicatedStorage.Modules.FPS.Bullet).CreateBullet = aimmodfunc
        else
            require(game.ReplicatedStorage.Modules.FPS.Bullet).CreateBullet = aimogfunc
        end
    end
})
aim:AddToggle({
    text = "Target AI",
    flag = "TargetAI",
    callback = function(v)
        aimbots = v
    end
})
aim:AddToggle({
    text = "Wall Check",
    flag = "WallCheck",
    callback = function(v)
        aimvischeck = v
    end
})
aim:AddToggle({
    text = "Auto Shoot",
    flag = "AutoShoot",
    risky = true,
    callback = function(v)
        aimtrigger = v
    end
})
aim:AddToggle({
    text = "[!] Animation Resolver",
    flag = "AnimResolver",
    risky = true,
    callback = function(v)
        resolver = v
    end
})

aim:AddList({
    enabled = true,
    text = "Hitbox", 
    tooltip = "Aimbot Hitbox",
    selected = "Head",
    multi = false,
    open = false,
    max = 4,
    values = {"Head", "Torso", "Legs", "Random"},
    risky = false,
    callback = function(v)
        aimpart = v
    end
})

aim:AddList({
    enabled = true,
    text = "Method", 
    tooltip = "Aimbot Method",
    selected = "Instant Hit",
    multi = false,
    open = false,
    max = 4,
    values = {"Instant Hit", "Prediction"},
    risky = false,
    callback = function(v)
        aimtype = v
    end
})

--[[aim:AddBox({
    enabled = true,
    name = "TextBox1",
    flag = "TextBox_1",
    input = "PlaceHolder1",
    focused = false,
    risky = false,
    callback = function(v)
        print(v)
    end
})--]]

--[[aim:AddToggle({
    text = "Toggle1",
    flag = "Toggle_1",
    callback = function(v)
        print(ValueText, v)
    end
}):AddColor({
    text = "Color1",
    color = Color3.fromRGB(255, 255, 255),
    flag = "Color_1",
    callback = function(v)
        print(ValueText, v)
    end
})--]]

--[[aim:AddBind({
    enabled = true,
    text = "Keybind1",
    tooltip = "tooltip1",
    mode = "toggle",
    bind = "None",
    flag = "ToggleKey_1",
    state = false,
    nomouse = false,
    risky = false,
    noindicator = false,
    callback = function(v)
        print(ValueText, v)
    end,
    keycallback = function(v)
        print(ValueText, v)
    end
})--]]

aim:AddSeparator({
    enabled = true,
    text = "Visual"
})

--[[aim:AddButton({
    enabled = true,
    text = "Button1",
    tooltip = "tooltip1",
    confirm = true,
    risky = false,
    callback = function()
        print("Pressed!")
    end
})--]]

-- Button1:SetText("Text")
aim:AddToggle({
    text = "FOV Visible",
    flag = "FOVvisible",
    callback = function(v)
        aimfovcircle.Visible = v
    end
})
aim:AddToggle({
    text = "Dynamic FOV",
    flag = "sefsfe",
    callback = function(v)
        aimdynamicfov = v
    end
})
aim:AddSlider({
    enabled = true,
    text = "FOV Radius",
    tooltip = "FOV Radius",
    flag = "FOVRadius",
    suffix = "",
    dragging = true,
    focused = false,
    min = 10,
    max = 350,
    increment = 1,
    risky = false,
    callback = function(v)
        aimfov = v
    end
})

--Slider_1:SetValue(100)

aim:AddColor({
    enabled = true,
    text = "FOV Color",
    tooltip = "FOV Color",
    color = Color3.fromRGB(77, 210, 255),
    flag = "Color_1",
    trans = 0,
    open = false,
    risky = false,
    callback = function(v)
        aimfovcircle.Color = v
    end
})


gunmods:AddToggle({
    text = "Rapid Fire",
    flag = "dhftdfjhtydjtfy",
    risky = true,
    callback = function(v)
            RapidFire = v
    if v == true then
        local inv = game.ReplicatedStorage.Players:FindFirstChild(localplayer.Name).Inventory
        for i,v in ipairs(inv:GetChildren()) do
            local sett = require(v.SettingsModule)
            sett.FireRate = 0.002
        end
    else
        local inv = game.ReplicatedStorage.Players:FindFirstChild(localplayer.Name).Inventory
        for i,v in ipairs(inv:GetChildren()) do
            local sett = require(v.SettingsModule)
            local toset = 0.05
            toset = 60 / v.ItemProperties.Tool:GetAttribute("FireRate")
            sett.FireRate = toset
        end
    end
    end
})

gunmods:AddToggle({
    text = "Unlock Firemodes",
    flag = "Ashetrshert",
    risky = true,
    callback = function(v)
        UnlockFiremodes = v
    end
})

gunmods:AddToggle({
    text = "Instant Equip",
    flag = "Ashetrsdwawdert",
    callback = function(v)
        InstaEquip = v
    end
})

gunmods:AddToggle({
    text = "Wallbang",
    flag = "Ashetgrdrshert",
    callback = function(v)
        aimbang = v
    end
})

gunmods:AddToggle({
    text = "No Recoil",
    flag = "gdfAshetrshert",
    callback = function(v)
        			NoRecoil = v
			if NoRecoil and rp:FindFirstChild("AmmoTypes") then
				for i,v in ipairs(rp.AmmoTypes:GetChildren()) do
					if v then
						v:SetAttribute("RecoilStrength", 0)
					end
				end
			elseif not NoRecoil and rp:FindFirstChild("AmmoTypes") then
				for i,v in ipairs(rp.AmmoTypes:GetChildren()) do
					if v then
						local realAmmo = realAmmoTypes:FindFirstChild(v.Name)
						if realAmmo then
							v:SetAttribute("RecoilStrength", realAmmo:GetAttribute("RecoilStrength"))
						end
					end
				end
			end
    end
})

local reloadRemote = rp:WaitForChild("Remotes"):WaitForChild("Reload")

gunmods:AddToggle({
    text = "Instant Reload",
    flag = "Ashetrsdfshert",
    callback = function(v)
            InstaReload = v
    if InstaReload then
	    while InstaReload do
	      	reloadRemote:InvokeServer()
	     	wait(0.00001)
	    end
    end
    end
})

gunmods:AddToggle({
    text = "No Drag",
    flag = "Ashetrshfesert",
    callback = function(v)
        	GunDrag = v
	if GunDrag and rp:FindFirstChild("AmmoTypes") then
		for i,v in ipairs(rp.AmmoTypes:GetChildren()) do
			if v then
				v:SetAttribute("Drag", 0)
			end
		end
	elseif not GunDrag and rp:FindFirstChild("AmmoTypes") then
		for i,v in ipairs(rp.AmmoTypes:GetChildren()) do
			if v then
				local realAmmo = realAmmoTypes:FindFirstChild(v.Name)
				if realAmmo then
					v:SetAttribute("Drag", realAmmo:GetAttribute("Drag"))
				end
	    	end
		end
	end
    end
})

gunmods:AddToggle({
    text = "No Sway",
    flag = "Ashetrssferhert",
    callback = function(v)
        NoSway = v
    end
})

gunmods:AddToggle({
    text = "No Projectile Drop",
    flag = "Ashetrssferhert",
    risky = true,
    callback = function(v)
        	NoProjectileDrop = v
	if NoProjectileDrop and rp:FindFirstChild("AmmoTypes") then
		for i,v in ipairs(rp.AmmoTypes:GetChildren()) do
			if v then
				v:SetAttribute("ProjectileDrop", 0)
			end
		end
	elseif not NoProjectileDrop and rp:FindFirstChild("AmmoTypes") then
		for i,v in ipairs(rp.AmmoTypes:GetChildren()) do
			if v then
				local realAmmo = realAmmoTypes:FindFirstChild(v.Name)
				if realAmmo then
					v:SetAttribute("ProjectileDrop", realAmmo:GetAttribute("ProjectileDrop"))
				end
			end
		end
	end
    end
})

gunmods:AddToggle({
    text = "Bullet Tracer",
    flag = "Ashetdsrssferhert",
    callback = function(v)
        	BulletTracer = v
	if BulletTracer and rp:FindFirstChild("AmmoTypes") then
		for i,v in ipairs(rp.AmmoTypes:GetChildren()) do
			if v then
				v:SetAttribute("Tracer", true)
			end
		end
	elseif not BulletTracer and rp:FindFirstChild("AmmoTypes") then
		for i,v in ipairs(rp.AmmoTypes:GetChildren()) do
			if v then
				local realAmmo = realAmmoTypes:FindFirstChild(v.Name)
				if realAmmo then
					v:SetAttribute("Tracer", realAmmo:GetAttribute("Tracer"))
				end
			end
		end
	end
    end
})

gunmods:AddSlider({
    enabled = true,
    text = "Burstfire",
    tooltip = "Shoots multiple bullets at once.",
    flag = "dtrhdhh",
    suffix = "",
    dragging = true,
    focused = false,
    min = 1,
    max = 100,
    increment = 1,
    risky = true,
    callback = function(v)
        BurstFire = v
    end
})

tarinfo:AddToggle({
    text = "Target Name",
    flag = "Ashgrgretfesrssferhert",
    callback = function(v)
        aimtargetname.Visible = v
    end
})

tarinfo:AddToggle({
    text = "Health",
    flag = "Ashgrgfsefsretrssferhert",
    callback = function(v)
        healthtargetname = v
    end
})

tarinfo:AddToggle({
    text = "Admin",
    flag = "Ashgrgrefnghtrssferhert",
    callback = function(v)
        admintargetname = v
    end
})

snapline:AddToggle({
    text = "Snapline Enabled",
    flag = "As42t",
    callback = function(v)
        snaplinebool = v
    end
})
snapline:AddColor({
    enabled = true,
    text = "Snapline Color",
    tooltip = "Snapline Color",
    color = Color3.fromRGB(77, 210, 255),
    flag = "Color_rsdg1",
    trans = 0,
    open = false,
    risky = false,
    callback = function(v)
        aimsnapline.Color = v
    end
})

local function movementtoggle(v)
    if localplayer.Character and localplayer.Character:FindFirstChild("HumanoidRootPart") and localplayer.Character:FindFirstChild("Humanoid") then
        if v then
            if not semifly_bodyvel then
                semifly_bodyvel = Instance.new("BodyVelocity", localplayer.Character.HumanoidRootPart)
                semifly_bodyvel.Velocity = Vector3.new(0, 0, 0)
                semifly_bodyvel.MaxForce = Vector3.new(1e4, 1e4, 1e4)
            end
        else
            if semifly_bodyvel then
                semifly_bodyvel:Destroy()
                semifly_bodyvel = nil
            end
        end

        local humanoid = localplayer.Character:FindFirstChild("Humanoid")
        if humanoid then
            humanoid.PlatformStand = v
        end

        charsemifly = v
    else
        if semifly_bodyvel then
            semifly_bodyvel:Destroy()
            semifly_bodyvel = nil
        end
        charsemifly = false
    end
end

semifly:AddToggle({
    text = "Movement Toggle",
    state = false,
    risky = true,
    flag = "MovementToggle",
    callback = function(v)
        movementtoggle(v)
    end
}):AddBind({
    enabled = true,
    text = "Movement Toggle",
    tooltip = "Movement Toggle Keybind",
    mode = "toggle",
    bind = Enum.KeyCode.X,
    flag = "ToggleKey_5",
    state = false,
    nomouse = false,
    risky = false,
    noindicator = false,
    callback = function(v)
        movementtoggle(v)
    end,
    keycallback = function(v)
        movementtoggle(v)
    end
})

semifly:AddSlider({
    enabled = true,
    text = "Max Height Distance",
    tooltip = "Movement Max Height Distance",
    flag = "dtrhtgh4dhh",
    suffix = "",
    dragging = true,
    focused = false,
    min = 1,
    max = 8,
    increment = 1,
    callback = function(v)
        charsemiflydist = v
    end
})

semifly:AddSlider({
    enabled = true,
    text = "Speed",
    tooltip = "Movement Speed",
    flag = "dtr3htgh4dhh",
    suffix = "",
    dragging = true,
    focused = false,
    min = 1,
    max = 90,
    increment = 1,
    callback = function(v)
        charsemiflyspeed = v
    end
})

semifly:AddSeparator({
    enabled = true,
    text = "Anti Aim Toggles"
})

semifly:AddToggle({
    text = "Custom Rotation",
    flag = "Ashgrgretfesrssferhert",
    risky = true,
    callback = function(v)
        charantiaim_underground = v
    end
})

semifly:AddToggle({
    text = "UpAngle Toggle",
    flag = "Ashgrgretfesrssferhert",
    risky = true,
    callback = function(v)
        upangletoggle = v
    end
})

semifly:AddSlider({
    enabled = true,
    text = "UpAngle Value",
    tooltip = "UpAngle Value",
    flag = "dxgfgdhh",
    suffix = "",
    dragging = true,
    focused = false,
    min = -5,
    max = 5,
    increment = 1,
    callback = function(v)
        upangleY = v
    end
})

semifly:AddSeparator({
    enabled = true,
    text = "Anti Aim Parameters"
})

semifly:AddSlider({
    enabled = true,
    text = "X Rotation",
    tooltip = "X Axis Rotation",
    flag = "dx2gfgdhh",
    suffix = "",
    dragging = true,
    focused = false,
    min = 0,
    max = 180,
    increment = 1,
    callback = function(v)
        xrot = v
    end
})

semifly:AddSlider({
    enabled = true,
    text = "Y Rotation",
    tooltip = "Y Axis Rotation",
    flag = "dxYgfgdhh",
    suffix = "",
    dragging = true,
    focused = false,
    min = 0,
    max = 10,
    increment = 1,
    callback = function(v)
        yrot = v
    end
})

semifly:AddSlider({
    enabled = true,
    text = "Z Rotation",
    tooltip = "Z Axis Rotation",
    flag = "dxZgfgdhh",
    suffix = "",
    dragging = true,
    focused = false,
    min = 0,
    max = 10,
    increment = 1,
    callback = function(v)
        zrot = v
    end
})

semifly:AddSeparator({
    enabled = true,
    text = "Anti Aim Spin"
})

semifly:AddToggle({
    text = "Spin X",
    flag = "A4536dd",
    risky = false,
    callback = function(v)
            xspinning = v
    if not xspinning then
        xrot = 0
    else
        coroutine.wrap(function()
            while xspinning do
                xrot = (xrot + xspeedspin * 2) % 360
                runs.RenderStepped:Wait()
            end
        end)()
    end
    end
})

semifly:AddSlider({
    enabled = true,
    text = "X Rotation Speed",
    tooltip = "X Axis Rotation Speed",
    flag = "dxZgfgdhh",
    suffix = "",
    dragging = true,
    focused = false,
    min = 0,
    max = 20,
    increment = 1,
    callback = function(v)
        xspeedspin = v
    end
})

semifly:AddToggle({
    text = "Spin Y",
    flag = "A453f6dd",
    risky = false,
    callback = function(v)
            yspinning = v
    if not yspinning then
        yrot = 0
    else
        coroutine.wrap(function()
            while yspinning do
                yrot = (yrot + yspeedspin * 2) % 360
                runs.RenderStepped:Wait()
            end
        end)()
    end
    end
})

semifly:AddSlider({
    enabled = true,
    text = "Y Rotation Speed",
    tooltip = "Y Axis Rotation Speed",
    flag = "dxZgfghhdhh",
    suffix = "",
    dragging = true,
    focused = false,
    min = 0,
    max = 20,
    increment = 1,
    callback = function(v)
        yspeedspin = v
    end
})

semifly:AddToggle({
    text = "Spin Z",
    flag = "A4zz536dd",
    risky = false,
    callback = function(v)
            zspinning = v
    if not zspinning then
        zrot = 0
    else
        coroutine.wrap(function()
            while zspinning do
                zrot = (zrot + zspeedspin * 2) % 360
                runs.RenderStepped:Wait()
            end
        end)()
    end
    end
})

semifly:AddSlider({
    enabled = true,
    text = "Z Rotation Speed",
    tooltip = "Z Axis Rotation Speed",
    flag = "dxsssdwdZgfgdhh",
    suffix = "",
    dragging = true,
    focused = false,
    min = 0,
    max = 20,
    increment = 1,
    callback = function(v)
        zspeedspin = v
    end
})

function startspeedhack()
    local speaker = game:GetService("Players").LocalPlayer
    local chr = speaker.Character
    local hum = chr and chr:FindFirstChildWhichIsA("Humanoid")
    local hb = game:GetService("RunService").Heartbeat
    while speedbool and chr and hum and hum.Parent do
        local delta = hb:Wait()
        if hum.MoveDirection.Magnitude > 0 then
            chr:TranslateBy(hum.MoveDirection * tonumber(speedboost) * delta * 10)
        else
            chr:TranslateBy(hum.MoveDirection * delta * 10)
        end
    end
end

privatefeatures:AddSeparator({
    enabled = true,
    text = "CFrame Speed"
})

privatefeatures:AddToggle({
    text = "CFrame Speed Enabled",
    flag = "Abay2u654fdt",
    callback = function(v)
        speedbool = v
        startspeedhack()
    end
})

privatefeatures:AddSlider({
    enabled = true,
    text = "CFrame Speed",
    tooltip = "CFrame Speed Value",
    flag = "dxsssdwdZgfgdhh",
    suffix = "",
    dragging = true,
    focused = false,
    min = 0,
    max = 1.5,
    increment = 0.1,
    callback = function(v)
        speedboost = v
    end
})

privatefeatures:AddSeparator({
    enabled = true,
    text = "Player Exploits"
})

privatefeatures:AddToggle({
    text = "Main Toggle",
    flag = "Abx2ay2u654fdt",
    callback = function(v)
        changerbool = v
    end
})

privatefeatures:AddSlider({
    enabled = true,
    text = "Player Walkspeed",
    tooltip = "Walkspeed Value",
    flag = "dxsssdwd234rZgfgdhh",
    suffix = "",
    dragging = true,
    focused = false,
    min = 0,
    max = 70,
    increment = 1,
    callback = function(v)
        changerspeed = v
    end
})

privatefeatures:AddSlider({
    enabled = true,
    text = "Player Jumppower",
    tooltip = "Jumppower Value",
    flag = "dwa2dxsssdwd234rZgfgdhh",
    suffix = "",
    dragging = true,
    focused = false,
    min = 0,
    max = 25,
    increment = 1,
    callback = function(v)
        changerjump = v
    end
})

privatefeatures:AddSlider({
    enabled = true,
    text = "Player Hipheight",
    tooltip = "Hipheight Value",
    flag = "dwa2dHipheightxdhh",
    suffix = "",
    dragging = true,
    focused = false,
    min = 0,
    max = 25,
    increment = 1,
    callback = function(v)
        changerheight = v
    end
})

privatefeatures:AddSlider({
    enabled = true,
    text = "Player Gravity",
    tooltip = "Gravity Value",
    flag = "dwdhPlayerGravityh",
    suffix = "",
    dragging = true,
    focused = false,
    min = 0,
    max = 300,
    increment = 1,
    callback = function(v)
        changergrav = v
    end
})

privatefeatures:AddSeparator({
    enabled = true,
    text = "Other Exploits"
})

privatefeatures:AddToggle({
    text = "Jesus",
    flag = "Abx2ay2uJezus654fdt",
    callback = function(v)
        worldjesus = v
        if v then
            while worldjesus do
                wait()
                local hitPart = workspace:Raycast(localplayer.Character:FindFirstChild("HumanoidRootPart").Position, Vector3.new(0, -5, 0) + localplayer.Character:FindFirstChild("HumanoidRootPart").CFrame.LookVector * 5, RaycastParams.new())
                if hitPart and hitPart.Material == Enum.Material.Water then
                    local clone = Instance.new("Part")
                    clone.Parent = waterplatforms
                    clone.Position = hitPart.Position
                    clone.Anchored = true
                    clone.CanCollide = true
                    clone.Size = Vector3.new(10,0.2,10)
                    clone.Transparency = 1
                end
            end
        else
            for i,v in ipairs(waterplatforms:GetChildren()) do
                v:Destroy()
            end
        end
    end
})

function isFalling()
    local humanoid = localplayer.Character and localplayer.Character:FindFirstChild("Humanoid")
    return humanoid and humanoid:GetState() == Enum.HumanoidStateType.Freefall
end

function createSafetyPart()
    local rootPart = localplayer.Character and localplayer.Character:FindFirstChild("HumanoidRootPart")
    if rootPart then
        local safetyPart = Instance.new("Part")
        safetyPart.Size = Vector3.new(4, 0.5, 4)
        safetyPart.Anchored = true
        safetyPart.CanCollide = true
        safetyPart.Transparency = transparencyToggle and 0 or 1
        safetyPart.BrickColor = BrickColor.new("Cyan")
        safetyPart.Material = Enum.Material.ForceField
        safetyPart.Position = rootPart.Position - Vector3.new(0, 4.9, 0)
        safetyPart.Parent = game.Workspace

        safetyPart.Touched:Connect(function(hit)
            if hit and hit.Parent == localplayer.Character then
                safetyPart:Destroy()
            end
        end)

        delay(0.05, function()
            if safetyPart and safetyPart.Parent then
                safetyPart:Destroy()
            end
        end)
    end
end

local function startFallProtection()
    while NoFallDamage do
        if isFalling() then
            createSafetyPart()
        end
        wait(0.1)
    end
end

privatefeatures:AddToggle({
    text = "Bunnyhop",
    flag = "Abannit",
    callback = function(v)
        bunnyhop = v
        repeat
            if localplayer.Character and localplayer.Character:FindFirstChildWhichIsA("Humanoid") then
                localplayer.Character.Humanoid:SetAttribute("JumpCooldown", 0)
            end
            task.wait()
        until not bunnyhop
    end
})

privatefeatures:AddToggle({
    text = "Gnome Mode",
    flag = "gnome359",
    risky = true,
    tooltip = "Moves your limbs and head into your torso",
    callback = function(v)
        game.ReplicatedStorage.Remotes.UpdateTilt:FireServer(v and 0/0 or 0)
    end
})

privatefeatures:AddToggle({
    text = "No Fall Damage",
    tooltip = "Main Toggle for No Fall Damage",
    flag = "Abanxnidwaawfdt",
    callback = function(v)
        NoFallDamage = v
        if v then
            startFallProtection()
        end
    end
})

privatefeatures:AddToggle({
    text = "Visualize",
    tooltip = "Visualizes No Fall Damage",
    flag = "Abayu654fdt",
    callback = function(v)
        transparencyToggle = v
    end
})

wh:AddToggle({
    text = "ESP Enabled",
    tooltip = "Main Toggle for ESP",
    flag = "v5u54354",
    callback = function(v)
        espbool = v
    end
})

wh:AddToggle({
    text = "AI",
    tooltip = "Includes AI in ESP",
    flag = "v5u543x54",
    callback = function(v)
        espbots = v
    end
})

wh:AddToggle({
    text = "Name",
    tooltip = "Includes Names in ESP",
    flag = "v5u543x54",
    callback = function(v)
        espname = v
    end
})

wh:AddToggle({
    text = "Health",
    tooltip = "Includes Health in ESP",
    flag = "v5uHealth543x54",
    callback = function(v)
        esphp = v
    end
})

wh:AddToggle({
    text = "Distance",
    tooltip = "Includes Distance in ESP",
    flag = "v5u5Distance43x54",
    callback = function(v)
        espdistance = v
    end
})

wh:AddToggle({
    text = "Chams",
    tooltip = "Includes Chams in ESP",
    flag = "v5uChams543x54",
    callback = function(v)
        esphigh = v
    end
})

wh:AddToggle({
    text = "Equipped Tool",
    tooltip = "Includes Equipped Tool in ESP",
    flag = "v5EquippedTool543x54",
    callback = function(v)
        esphotbar = v
    end
})

wh:AddToggle({
    text = "Body",
    tooltip = "Includes Dead Bodies in ESP",
    flag = "v5Body543x54",
    callback = function(v)
        espdead = v
    end
})

wh:AddToggle({
    text = "Extract",
    tooltip = "Includes Extracts in ESP",
    flag = "v5Extract543x54",
    callback = function(v)
        espexit = v
    end
})

wh:AddSeparator({
    enabled = true,
    text = "ESP Parameters"
})

wh:AddSlider({
    enabled = true,
    text = "Text Size",
    tooltip = "ESP Text Size",
    flag = "dwdhTextSizeavityh",
    suffix = "",
    dragging = true,
    focused = false,
    min = 1,
    max = 35,
    increment = 1,
    callback = function(v)
        esptextsize = v
    end
})

wh:AddToggle({
    text = "Text Outline",
    tooltip = "Adds a Text Outline to ESP",
    flag = "v5ETextOutlinet543x54",
    callback = function(v)
        esptextline = v
    end
})

wh:AddSeparator({
    enabled = true,
    text = "Cham Parameters"
})

wh:AddSlider({
    enabled = true,
    text = "Chams Outline Transparency",
    flag = "dwdhTexjrjrzeavityh",
    suffix = "",
    dragging = true,
    focused = false,
    min = 0,
    max = 1,
    increment = 0.1,
    callback = function(v)
        espchamsline = v
    end
})
wh:AddColor({
    enabled = true,
    text = "Chams Outline Color",
    color = Color3.fromRGB(77, 210, 255),
    flag = "Color_92",
    trans = 0,
    open = false,
    risky = false,
    callback = function(v)
        esplinecolor = v
    end
})
wh:AddSlider({
    enabled = true,
    text = "Chams Fill Transparency",
    flag = "dwdhTegfrgzeavityh",
    suffix = "",
    dragging = true,
    focused = false,
    min = 0,
    max = 1,
    increment = 0.1,
    callback = function(v)
        espchamsfill = v
    end
})
wh:AddColor({
    enabled = true,
    text = "Chams Fill Color",
    color = Color3.fromRGB(77, 210, 255),
    flag = "Color_61",
    trans = 0,
    open = false,
    risky = false,
    callback = function(v)
        espfillcolor = v
    end
})

cross:AddToggle({
    text = "Crosshair Enabled",
    tooltip = "Enables/disables crosshair",
    flag = "v5ETexehtt543x54",
    callback = function(v)
        crosshair.Visible = v
    end
})

cross:AddColor({
    enabled = true,
    text = "Crosshair Color",
    color = Color3.fromRGB(77, 210, 255),
    flag = "Color_612",
    trans = 0,
    open = false,
    risky = false,
    callback = function(v)
        crosshair.Color = v
    end
})

tracers:AddToggle({
    text = "Bullet Tracers Enabled",
    tooltip = "Enables/disables Bullet Tracers",
    flag = "v5ET3yt4543x54",
    callback = function(v)
        tracbool = v
    end
})

tracers:AddList({
    enabled = true,
    text = "Tracer Texture", 
    tooltip = "Bullet Tracer Texture",
    selected = "Neon",
    multi = false,
    open = false,
    max = 4,
    values = {"None", "Neon", "Lightning", "Wide"},
    risky = false,
    callback = function(v)
        tracertexture = tracertextures[v]
    end
})

tracers:AddColor({
    enabled = true,
    text = "Bullet Tracer Color",
    color = Color3.fromRGB(77, 210, 255),
    flag = "Color_612x",
    trans = 0,
    open = false,
    risky = false,
    callback = function(v)
        traccolor.Color = Color3.fromRGB(v)
    end
})

tracers:AddSlider({
    enabled = true,
    text = "Tracer Lifetime",
    flag = "dwTracerLifetimetyh",
    suffix = "",
    dragging = true,
    focused = false,
    min = 0.5,
    max = 20,
    increment = 0.5,
    callback = function(v)
        tracwait = v
    end
})

worldh:AddToggle({
    text = "No Grass",
    tooltip = "Adds/Removes Grass",
    flag = "v5ET3ytGrass4543x54",
    callback = function(v)
        sethiddenproperty(workspace.Terrain, "Decoration", not v)
    end
})

worldh:AddToggle({
    text = "No Leaves",
    tooltip = "Adds/Removes Leaves",
    flag = "v5ET3ytLeaves4543x54",
    callback = function(v)
        worldleaves = v
    end
})

worldh:AddSeparator({
    enabled = true,
    text = "Lighting Parameters"
})

worldh:AddSlider({
    enabled = true,
    text = "Clock Time",
    flag = "dwdhTClockTimevityh",
    suffix = "h",
    dragging = true,
    focused = false,
    min = 0,
    max = 24,
    increment = 0.1,
    callback = function(v)
        worldclock = v
        game.Lighting.ClockTime = v
    end
})

worldh:AddToggle({
    text = "No Fog",
    tooltip = "Enables/Disables Fog",
    flag = "v5ET3yFogs4543x54",
    callback = function(v)
        while v do task.wait()
            game.Lighting.Atmosphere.Density = 0
            game.Lighting.Atmosphere.Offset = 0
        end
    end
})
local prevAmbient = game.Lighting.Ambient
local prevOutdoor = game.Lighting.OutdoorAmbient
worldh:AddToggle({
    text = "Ambient Toggle",
    tooltip = "Enables/Disables Ambient Modifier",
    flag = "v5ET3yAmbientToggl4543x54",
    callback = function(v)
        worldvisualstoggle = v
        if worldvisualstoggle then
            game.Lighting.Ambient = worldambient
            game.Lighting.OutdoorAmbient = worldoutdoor
        else
            game.Lighting.Ambient = prevAmbient
            game.Lighting.OutdoorAmbient = prevOutdoor
        end
    end
})

worldh:AddColor({
    enabled = true,
    text = "Ambient Color",
    color = Color3.fromRGB(255, 255, 255),
    flag = "Color_682x",
    trans = 0,
    open = false,
    risky = false,
    callback = function(v)
        worldambient = v
    end
})

worldh:AddColor({
    enabled = true,
    text = "Outdoor Ambient Color",
    color = Color3.fromRGB(255, 255, 255),
    flag = "Color_68h2x",
    trans = 0,
    open = false,
    risky = false,
    callback = function(v)
        worldoutdoor = v
    end
})

viewmod:AddToggle({
    text = "Viewmodel Chams",
    tooltip = "Enables/Disables Viewmodel Chams",
    flag = "v3yViewmodelChams44",
    callback = function(v)
        viewmodbool = v
    end
})
viewmod:AddList({
    enabled = true,
    text = "Arm Chams Material", 
    selected = "Forcefield",
    multi = false,
    open = false,
    max = 4,
    values = {"Neon", "Forcefield", "Plastic"},
    risky = false,
    callback = function(v)
        if viewmod_materials[v] then
            viewmodhandmat = viewmod_materials[v]
        else
    
        end
    end
})
viewmod:AddList({
    enabled = true,
    text = "Weapon Chams Material", 
    selected = "Forcefield",
    multi = false,
    open = false,
    max = 4,
    values = {"Neon", "Forcefield", "Plastic"},
    risky = false,
    callback = function(v)
        if viewmod_materials[v] then
            viewmodgunmat = viewmod_materials[v]
        else
    
        end
    end
})
viewmod:AddColor({
    enabled = true,
    text = "Arm Chams Color",
    color = Color3.fromRGB(77, 210, 255),
    flag = "Color_ArmChams",
    trans = 0,
    open = false,
    risky = false,
    callback = function(v)
        viewmodhandcolor = v
    end
})
viewmod:AddColor({
    enabled = true,
    text = "Weapon Chams Color",
    color = Color3.fromRGB(77, 210, 255),
    flag = "Color_WeaponChams",
    trans = 0,
    open = false,
    risky = false,
    callback = function(v)
        viewmodguncolor = v
    end
})

viewmod:AddSeparator({
    enabled = true,
    text = "Outline Chams"
})

viewmod:AddToggle({
    text = "Viewmodel Outline Chams",
    tooltip = "Enables/Disables Viewmodel Outline Chams",
    flag = "v3yOutlineViewmodelChams44",
    callback = function(v)
        viewmodhighlightchams = v
    end
})

viewmod:AddColor({
    enabled = true,
    text = "Outline Fill Color",
    color = Color3.fromRGB(77, 210, 255),
    flag = "Color_OutlineFill",
    trans = 0,
    open = false,
    risky = false,
    callback = function(v)
        viewmodhighlightfillcolor = v
    end
})

viewmod:AddSlider({
    enabled = true,
    text = "Outline Fill Transparency",
    flag = "dwOutlineFillTranstyh",
    suffix = "",
    dragging = true,
    focused = false,
    min = 0,
    max = 1,
    increment = 0.1,
    callback = function(v)
        viewmodhighlightfilltransparency = v
    end
})

viewmod:AddColor({
    enabled = true,
    text = "Outline Color",
    color = Color3.fromRGB(77, 210, 255),
    flag = "Color_Outline",
    trans = 0,
    open = false,
    risky = false,
    callback = function(v)
        viewmodhighlightoutlinecolor = v
    end
})

viewmod:AddSlider({
    enabled = true,
    text = "Outline Transparency",
    flag = "dwFillTranstyh",
    suffix = "",
    dragging = true,
    focused = false,
    min = 0,
    max = 1,
    increment = 0.1,
    callback = function(v)
        viewmodhighlightoutlinetransparency = v
    end
})

local zoomtoggle = false

local classicfov = 100
local zoomfov = 5

camzoom:AddToggle({
    text = "Zoom",
    tooltip = "Enables/Disables Zoom",
    flag = "v5ET3yAmbientToggl4543x54",
    callback = function(v)
if zoomtoggle then
			if rp.Players and rp.Players:FindFirstChild(localplayer.Name) and rp.Players:FindFirstChild(localplayer.Name).Settings then
				local settings = rp.Players:FindFirstChild(localplayer.Name).Settings
                                zoomtoggle = false
				settings.GameplaySettings:SetAttribute("DefaultFOV", classicfov)
			end
else
	                if rp.Players and rp.Players:FindFirstChild(localplayer.Name) and rp.Players:FindFirstChild(localplayer.Name).Settings then
		                local settings = rp.Players:FindFirstChild(localplayer.Name).Settings
                                zoomtoggle = true
		                 settings.GameplaySettings:SetAttribute("DefaultFOV", zoomfov)
	                end
end
    end
}):AddBind({
    enabled = true,
    text = "Zoom",
    tooltip = "Zoom Keybind",
    mode = "toggle",
    bind = Enum.KeyCode.C,
    flag = "ToggleKey_2",
    state = false,
    nomouse = false,
    risky = false,
    noindicator = false,
    callback = function(v)
if zoomtoggle then
			if rp.Players and rp.Players:FindFirstChild(localplayer.Name) and rp.Players:FindFirstChild(localplayer.Name).Settings then
				local settings = rp.Players:FindFirstChild(localplayer.Name).Settings
                                zoomtoggle = false
				settings.GameplaySettings:SetAttribute("DefaultFOV", classicfov)
			end
else
	                if rp.Players and rp.Players:FindFirstChild(localplayer.Name) and rp.Players:FindFirstChild(localplayer.Name).Settings then
		                local settings = rp.Players:FindFirstChild(localplayer.Name).Settings
                                zoomtoggle = true
		                 settings.GameplaySettings:SetAttribute("DefaultFOV", zoomfov)
	                end
end
    end,
    keycallback = function(v)
if zoomtoggle then
			if rp.Players and rp.Players:FindFirstChild(localplayer.Name) and rp.Players:FindFirstChild(localplayer.Name).Settings then
				local settings = rp.Players:FindFirstChild(localplayer.Name).Settings
                                zoomtoggle = false
				settings.GameplaySettings:SetAttribute("DefaultFOV", classicfov)
			end
else
	                if rp.Players and rp.Players:FindFirstChild(localplayer.Name) and rp.Players:FindFirstChild(localplayer.Name).Settings then
		                local settings = rp.Players:FindFirstChild(localplayer.Name).Settings
                                zoomtoggle = true
		                 settings.GameplaySettings:SetAttribute("DefaultFOV", zoomfov)
	                end
end
    end
})

camzoom:AddSlider({
    enabled = true,
    text = "Base FOV",
    flag = "dwdhTBaseFOVevityh",
    suffix = "",
    dragging = true,
    focused = false,
    min = 5,
    max = 100,
    increment = 1,
    callback = function(v)
        classicfov = v
    end
})

camzoom:AddSlider({
    enabled = true,
    text = "Zoom FOV",
    flag = "dwdhTZoomFOVevityh",
    suffix = "",
    dragging = true,
    focused = false,
    min = 5,
    max = 80,
    increment = 1,
    callback = function(v)
        zoomfov = v
    end
})

inventorychecker:AddToggle({
    text = "Inventory Checker",
    tooltip = "Enables/Disables Inventory Checker",
    flag = "v5ET3yInventoryChecker4543x54",
    callback = function(v)
        inventoryCheckerToggle = v
    end
}):AddBind({
    enabled = true,
    text = "Inventory Checker",
    tooltip = "Inventory Checker Keybind",
    mode = "toggle",
    bind = Enum.KeyCode.Backquote,
    flag = "ToggleKey_3",
    state = false,
    nomouse = false,
    risky = false,
    noindicator = false,
    callback = function(v)
        inventoryCheckerToggle = v
    end,
    keycallback = function(v)
        inventoryCheckerToggle = v
    end
})

camer:AddToggle({
    text = "No Effects",
    tooltip = "Enables/Disables Screen Effects",
    flag = "v5ET3yAScreenEffectse4543x54",
    callback = function(v)
        local noscreeneffects = v

        while noscreeneffects do task.wait(0.1)
        local pg = localplayer.PlayerGui
            if pg and pg:FindFirstChild("MainGui") and pg.MainGui:FindFirstChild("MainFrame") and pg.MainGui.MainFrame:FindFirstChild("ScreenEffects") then
                for i,v in ipairs(localplayer.PlayerGui.MainGui.MainFrame.ScreenEffects:GetChildren()) do
                    if v:IsA("Frame") then
                        v.Visible = false
                    end
                end
            end
        end
    end
})

local finishCharacterCreation = rp:WaitForChild("Remotes"):WaitForChild("FinishCharacterCreation")

local skinColors = {"1", "2", "3", "4", "5", "6", "7", "8"}
local faces = {"1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"}
local hairColors = {"1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21", "22", "23", "24"}
local hairs = {"M1", "M2", "M3", "M4", "M5", "M6", "M7", "M8", "M9", "M10", "M11", "M12"}

local toggleActive = false
local runningThread

local function fireCharacterCreation()
    for _, skinColor in ipairs(skinColors) do
        for _, face in ipairs(faces) do
            for _, hairColor in ipairs(hairColors) do
                for _, hair in ipairs(hairs) do
                    if not toggleActive then
                        return
                    end
                    
                    local args = {
                        [1] = {
                            ["SkinColor"] = skinColor,
                            ["Face"] = face,
                            ["HairColor"] = hairColor,
                            ["Hair"] = hair
                        }
                    }
                    
                    finishCharacterCreation:InvokeServer(unpack(args))
                    wait(0.01)
                end
            end
        end
    end
end

camer:AddToggle({
    text = "Appearance Switcher",
    tooltip = "Switches your appearance",
    flag = "v5ET3yAAppearance4543x54",
    callback = function(v)
        toggleActive = v
        if toggleActive then
            runningThread = coroutine.create(fireCharacterCreation)
            coroutine.resume(runningThread)
        else
            runningThread = nil
        end
    end
})

camer:AddToggle({
    text = "No Visor",
    tooltip = "Enables/Disables Visor Visibility",
    flag = "v5ET3yAVisor4543x54",
    callback = function(v)
        if v == true then
            game.Players.LocalPlayer.PlayerGui.MainGui.MainFrame.ScreenEffects.HelmetMask.TitanShield.Size = UDim2.new(0,0,1,0)
            game.Players.LocalPlayer.PlayerGui.MainGui.MainFrame.ScreenEffects.Mask.GP5.Size = UDim2.new(0,0,1,0)
            for i,v in ipairs(game.Players.LocalPlayer.PlayerGui.MainGui.MainFrame.ScreenEffects.Visor:GetChildren()) do
                v.Size = UDim2.new(0,0,1,0)
            end
        else
            game.Players.LocalPlayer.PlayerGui.MainGui.MainFrame.ScreenEffects.HelmetMask.TitanShield.Size = UDim2.new(1,0,1,0)
            game.Players.LocalPlayer.PlayerGui.MainGui.MainFrame.ScreenEffects.Mask.GP5.Size = UDim2.new(1,0,1,0)
            for i,v in ipairs(game.Players.LocalPlayer.PlayerGui.MainGui.MainFrame.ScreenEffects.Visor:GetChildren()) do
                v.Size = UDim2.new(1,0,1,0)
            end
        end
    end
})

camer:AddToggle({
    text = "No Flashbang",
    tooltip = "Enables/Disables Flashbang Effect",
    flag = "vFlasbang",
    callback = function(v)
        if v == true then
            game.Players.LocalPlayer.PlayerGui.MainGui.MainFrame.ScreenEffects.Flashbang.Size = UDim2.new(0,0,1,0)
        else
            game.Players.LocalPlayer.PlayerGui.MainGui.MainFrame.ScreenEffects.Flashbang.Size = UDim2.new(1,0,1,0)
        end
    end
})

local origZoom = localplayer.CameraMaxZoomDistance
local origMode = localplayer.CameraMode

local newZoom = 99999
local newMode = Enum.CameraMode.Classic

camer:AddToggle({
    text = "Third Person",
    tooltip = "Enables/Disables Third Person Ability",
    flag = "vThirdPerson",
    callback = function(v)
        isToggled = v
        if isToggled then
            localplayer.CameraMaxZoomDistance = newZoom
            localplayer.CameraMode = newMode
        else
            localplayer.CameraMaxZoomDistance = origZoom
            localplayer.CameraMode = origMode
        end
    end
})

camer:AddToggle({
    text = "No Drown",
    tooltip = "Enables/Disables Drown Damage",
    flag = "vDrown",
    risky = true,
    callback = function(v)
        AntiDrown = v
        if AntiDrown then
            game.Lighting.WaterBlur.Size = 0
        else
            game.Lighting.WaterBlur.Size = 24
        end
    end
})

hitsounds:AddToggle({
    text = "Hitsounds Enabled",
    tooltip = "Enables/Disables Custom Hitsounds",
    flag = "vHitsoundBool",
    callback = function(v)
        hitsoundbool = v
    end
})

hitsounds:AddList({
    enabled = true,
    text = "Headshot Hitsound", 
    selected = "Neverlose",
    multi = false,
    open = false,
    max = 4,
    values = {"Neverlose", "Gamesense", "Rust", "Bubble", "Minecraft", "Among-Us"},
    risky = false,
    callback = function(v)
        hitsoundhead = v

        local preview = Instance.new("Sound", workspace)
        preview.SoundId = hitsoundlib[v]
        preview:Play()
        task.wait(1)
        preview:Destroy()
    end
})

hitsounds:AddList({
    enabled = true,
    text = "Bodyhit Hitsound", 
    selected = "Gamesense",
    multi = false,
    open = false,
    max = 4,
    values = {"Neverlose", "Gamesense", "Rust", "Bubble", "Minecraft", "Among-Us"},
    risky = false,
    callback = function(v)
        hitsoundbody = v

        local preview = Instance.new("Sound", workspace)
        preview.SoundId = hitsoundlib[v]
        preview:Play()
        task.wait(1)
        preview:Destroy()
    end
})

--tracers--

local function runtracer(start, endp)
    -- Use tracertextures to find the texture ID if tracertexture is a key
    if tracertextures[tracertexture] then
        tracertexture = tracertextures[tracertexture]
    end

    local beam = Instance.new("Beam")
    beam.Name = "LineBeam"
    beam.Parent = game.Workspace

    local startpart = Instance.new("Part")
    startpart.CanCollide = false
    startpart.CanQuery = false
    startpart.Transparency = 1
    startpart.Position = start
    startpart.Parent = workspace
    startpart.Anchored = true
    startpart.Size = Vector3.new(0.01, 0.01, 0.01)

    local endpart = Instance.new("Part")
    endpart.CanCollide = false
    endpart.CanQuery = false
    endpart.Transparency = 1
    endpart.Position = endp
    endpart.Parent = workspace
    endpart.Anchored = true
    endpart.Size = Vector3.new(0.01, 0.01, 0.01)

    beam.Attachment0 = Instance.new("Attachment", startpart)
    beam.Attachment1 = Instance.new("Attachment", endpart)
    beam.Color = ColorSequence.new(traccolor, traccolor)
    beam.Width0 = 0.05
    beam.Width1 = 0.05
    beam.FaceCamera = true
    beam.Transparency = NumberSequence.new(0)
    beam.LightEmission = 1

    if tracertexture then
        beam.Texture = tracertexture
        beam.TextureSpeed = 3
        beam.TextureLength = (endp - start).Magnitude

        if tracertexture == "http://www.roblox.com/asset/?id=75056325012653" then
            beam.Width0 = 0.3
            beam.Width1 = 0.3
        elseif tracertexture == "http://www.roblox.com/asset/?id=7151778311" then
            beam.Width0 = 0.2
            beam.Width1 = 0.2
        end
    end

    wait(tracwait)

    for i = 0, 1, 0.1 do
        beam.Transparency = NumberSequence.new(i)
        wait(0.01)
    end

    beam:Destroy()
    startpart:Destroy()
    endpart:Destroy()
end


--silent aim--

local function isonscreen(object)
    local p, bool = wcamera:WorldToScreenPoint(object.Position)
    return bool
end
local v311 = require(game.ReplicatedStorage.Modules:WaitForChild("UniversalTables"))
local globalist11 = v311.ReturnTable("GlobalIgnoreListProjectile")
local function isvisible(char, object)
    if not localplayer.Character or not localplayer.Character:FindFirstChild("HumanoidRootPart") then
        return false
    end
    if aimvischeck == false then
        return true
    end

    local origin = localplayer.Character.HumanoidRootPart.Position + Vector3.new(0, 1, 0)
    if aimselftrack then
        local plrping = localplayer:GetNetworkPing()
        local key = math.floor((plrping + 5) / 10) * 10

        if selftrack_data[key] ~= nil then
            origin = selftrack_data[key]
        end
    end

    local pos = object.Position
    local dir = pos - origin
    local dist = dir.Magnitude + 5
    local penetrated = true
    dir = dir.Unit

    local params = RaycastParams.new()
    params.IgnoreWater = true
    params.CollisionGroup = "WeaponRay"
    params.FilterDescendantsInstances = {
        localplayer.Character:GetChildren(),
        wcamera:GetChildren(),
        globalist11,
        aimignoreparts
    }

    local ray = workspace:Raycast(origin, dir * dist, params)
    if aimbang then
        if ray and ray.Instance:IsDescendantOf(char) then
            return true
        elseif ray and ray.Instance.Name ~= "Terrain" and not ray.Instance:GetAttribute("NoPen") then
            local armorpen4 = 10
            local gname, gunmodel, guninv = getcurrentgun(localplayer)
            if guninv then
                armorpen4 = getcurrentammo(guninv):GetAttribute("ArmorPen")
            end

            local FunctionLibraryExtension = require(game.ReplicatedStorage.Modules.FunctionLibraryExtension)
            local armorpen1, newpos2 = FunctionLibraryExtension.Penetration(FunctionLibraryExtension, ray.Instance, ray.Position, dir, armorpen4)
            if armorpen1 == nil or newpos2 == nil then
                return false
            end

            local neworigin = ray.Position + dir * 0.01
            local newray = workspace:Raycast(neworigin, dir * (dist - (neworigin - origin).Magnitude), params)
            if newray and newray.Instance:IsDescendantOf(char) then
                return true
            end
        end
    else
        if ray and ray.Instance:IsDescendantOf(char) then
            return true
        end
    end

    return false
end
local function predictpos(tpart, bulletspeed, bulletdrop)
    local velocity = tpart.Velocity
    local distance = (wcamera.CFrame.Position - tpart.CFrame.Position).Magnitude
    local tth = (distance / bulletspeed)
    local predict1 = tpart.CFrame.Position + (velocity * tth)
    local delta = (predict1 - tpart.CFrame.Position).Magnitude
    local finalspeed = bulletspeed - 0.013 * bulletspeed ^ 2 * tth ^ 2
    tth += (delta / finalspeed)
    local predictres1 = tpart.CFrame.Position + (velocity * tth)
    local predictres2 = bulletdrop * tth ^ 2
    if tostring(drop_timing):find("nan") then
        predictres2 = 0
    end
    return predictres1 -- + Vector3.new(0,predictres2,0)
end
local function choosetarget()
    local cent = Vector2.new(wcamera.ViewportSize.X / 2, wcamera.ViewportSize.Y / 2)
    local cdist = math.huge
    local ctar = nil
    local cpart = nil

    local ammodistance = 999999999
    if aimdistcheck then
        local gname, gunmodel, guninv = getcurrentgun(localplayer)
        if guninv then
            armorpen4 = getcurrentammo(guninv):GetAttribute("MuzzleVelocity")
        end
    end

    local bparts = {
        "Head",
        "HeadTopHitBox",
        "FaceHitBox",
        "UpperTorso",
        "LowerTorso",
        "LeftUpperArm",
        "RightUpperArm",
        "LeftLowerArm",
        "RightLowerArm",
        "LeftHand",
        "RightHand",
        "LeftUpperLeg",
        "RightUpperLeg",
        "LeftLowerLeg",
        "RightLowerLeg",
        "LeftFoot",
        "RightFoot"
    }

    local xbparts = {
        "LeftLowerLeg",
        "RightLowerLeg",
        "LeftFoot",
        "RightFoot"
    }

    local function chooseTpart(charact)
        if aimpart == "Head" then
            return charact:FindFirstChild("Head")
        elseif aimpart == "Torso" then
            return charact:FindFirstChild("UpperTorso")
        elseif aimpart == "Legs" then
            return charact:FindFirstChild(xbparts[math.random(1, #xbparts)])
        elseif aimpart == "Scripted" then
            local head = charact:FindFirstChild("Head")
            local upperTorso = charact:FindFirstChild("UpperTorso")
            if not isvisible(charact, head) then
                return upperTorso
            else
                return head
            end
        elseif aimpart == "Random" then
            return charact:FindFirstChild(bparts[math.random(1, #bparts)])
        end
    end

    if aimbots then --priority 2 (bots)
        for _, botfold in ipairs(workspace.AiZones:GetChildren()) do
            for _, bot in ipairs(botfold:GetChildren()) do
                if bot:IsA("Model") and bot:FindFirstChild("Humanoid") and bot.Humanoid.Health > 0 then
                    if debuglistmode95x then
                        if debuglistmode24 == "Blacklist" then 
                            if table.find(debuglist95, bot.Name) ~= nil then
                                continue
                            end
                        elseif debuglistmode24 == "Whitelist" then 
                            if table.find(debuglist95, bot.Name) == nil then
                                continue
                            end
                        end
                    end

                    local potroot = chooseTpart(bot)
                    if potroot and localplayer.Character then
                        local spoint = wcamera:WorldToViewportPoint(potroot.Position)
                        local optpoint = Vector2.new(spoint.X, spoint.Y)
                        local dist = (optpoint - cent).Magnitude
                        
                        local betweendist = (localplayer.Character.PrimaryPart.Position - potroot.Position).Magnitude * 0.3336
                        local betweendistSTUDS = (localplayer.Character.PrimaryPart.Position - potroot.Position).Magnitude
                        if dist <= aimfovcircle.Radius and dist < cdist and betweendist < aimdistance and betweendistSTUDS < ammodistance then
                            local canvis = isvisible(bot, potroot)
                            if canvis and isonscreen(potroot) then
                                cdist = dist
                                ctar = bot
                                cpart = potroot
                            end
                        end
                    end
                end
            end
        end
    end

    for _, pottar in ipairs(game.Players:GetPlayers()) do --priority 1 (players)
        if pottar ~= localplayer and pottar.Character and localplayer.Character.PrimaryPart ~= nil then
            if debuglistmode24 == "Blacklist" then 
                if table.find(debuglist95, pottar.Name) ~= nil then
                    continue
                end
            elseif debuglistmode24 == "Whitelist" then 
                if table.find(debuglist95, pottar.Name) == nil then
                    continue
                end
            end

            local potroot = chooseTpart(pottar.Character)
            if potroot then
                local spoint = wcamera:WorldToViewportPoint(potroot.Position)
                local optpoint = Vector2.new(spoint.X, spoint.Y)
                local dist = (optpoint - cent).Magnitude
                
                local betweendist = (localplayer.Character.PrimaryPart.Position - potroot.Position).Magnitude * 0.3336
                local betweendistSTUDS = (localplayer.Character.PrimaryPart.Position - potroot.Position).Magnitude
                if dist <= aimfovcircle.Radius and dist < cdist and betweendist < aimdistance and betweendistSTUDS < ammodistance then
                    local canvis = isvisible(pottar.Character, potroot)
                    if canvis and isonscreen(potroot) then
                        cdist = dist
                        ctar = pottar
                        cpart = potroot
                    end
                end
            end
        end
    end

    if ctar == nil then
        aimtarget = nil
        aimtargetpart = nil
    else
        aimtarget = ctar
        aimtargetpart = cpart
    end
end

aimmodfunc = function(prikol, p49, p50, p_u_51, _, p52, p53, p54, p55)
    local v_u_6 = game.ReplicatedStorage.Remotes.VisualProjectile
    local v_u_108 = 1
    local v_u_106 = 0
    local v_u_7 = game.ReplicatedStorage.Remotes.FireProjectile
    local target = aimtarget
    local target_part
    local v_u_4 = require(game.ReplicatedStorage.Modules:WaitForChild("FunctionLibraryExtension"))
    local v9 = game:GetService("Players")
    local v_u_15 = v9.LocalPlayer
    local v_u_115 = v_u_4:GetEstimatedCameraPosition(v_u_15)
    local v_u_103
    local v_u_114
    local v_u_16 = game.ReplicatedStorage.Players:FindFirstChild(v_u_15.Name)
    local v_u_64 = v_u_16.Status.GameplayVariables:GetAttribute("EquipId")
    local v_u_13 = game.ReplicatedStorage:WaitForChild("VFX")
    local v_u_2 = require(game.ReplicatedStorage.Modules:WaitForChild("VFX"))
    local v3 = require(game.ReplicatedStorage.Modules:WaitForChild("UniversalTables"))
    local v_u_5 = game.ReplicatedStorage.Remotes.ProjectileInflict
    local v_u_10 = game:GetService("ReplicatedStorage")
    local v_u_12 = v_u_10:WaitForChild("RangedWeapons")
    local v_u_17 = game.ReplicatedStorage.Temp
    local v9 = game:GetService("Players")
    local v_u_56 = v_u_15.Character
    local v135 = 500000
    local v_u_18 = v3.ReturnTable("GlobalIgnoreListProjectile")
    local v_u_115 = v_u_4:GetEstimatedCameraPosition(v_u_15)
    local v65 = v_u_10.AmmoTypes:FindFirstChild(p52)
    local v_u_74 = v65:GetAttribute("Pellets")
    local v60 = p50.ItemRoot
    local v61 = p49.ItemProperties
    local v62 = v_u_12:FindFirstChild(p49.Name)
    local v63 = v61:FindFirstChild("SpecialProperties")
    local v_u_66 = v63 and v63:GetAttribute("TracerColor") or v62:GetAttribute("ProjectileColor")
    local itemprop = require(v_u_16.Inventory:FindFirstChild(p49.Name).SettingsModule)
    local bulletspeed = v65:GetAttribute("MuzzleVelocity")
    local armorpen4 = v65:GetAttribute("ArmorPen")
    local tracerendpos = Vector3.zero
    local v79 = {
        ["x"] = {
            ["Value"] = 0
        },
        ["y"] = {
            ["Value"] = 0
        }
    }

    if v_u_56:FindFirstChild(p49.Name) then
        local v83 = 0.001 
        local v82 = 0.001
        local v81 = 10000
        if v61.Tool:GetAttribute("MuzzleDevice") or "Default" == "Suppressor" then
            if tick() - p53 < 0.8 then
                v_u_4:PlaySoundV2(v60.FireSoundSupressed, v60.FireSoundSupressed.TimeLength, v_u_17)
            else
                v_u_4:PlaySoundV2(v60.FireSoundSupressed, v60.FireSoundSupressed.TimeLength, v_u_17)
            end
        elseif tick() - p53 < 0.8 then
            v_u_4:PlaySoundV2(v60.FireSound, v60.FireSound.TimeLength, v_u_17)
        else
            v_u_4:PlaySoundV2(v60.FireSound, v60.FireSound.TimeLength, v_u_17)
        end
        local v_u_59
        if p_u_51.Item.Attachments:FindFirstChild("Front") then
            v_u_59 = p_u_51.Item.Attachments.Front:GetChildren()[1].Barrel
            local _ = p50.Attachments.Front:GetChildren()[1].Barrel
        else
            v_u_59 = p_u_51.Item.Barrel
            local _ = p50.Barrel
        end

        if target ~= nil and aimtargetpart ~= nil then
            target_part = aimtargetpart
            if aimtype == "Prediction" then
                local buldrop = v65:GetAttribute("ProjectileDrop")
                local bulsp = v65:GetAttribute("MuzzleVelocity")
                target_part = predictpos(target_part, bulsp, buldrop)
                v_u_103 = CFrame.new(v_u_115, target_part).LookVector
            else
                v_u_103 = CFrame.new(v_u_115, target_part.Position).LookVector
            end
            v_u_114 = v_u_103
        else
            target_part = p55
            v_u_103 = CFrame.new(v_u_115, v_u_15:GetMouse().Hit.Position).LookVector
            v_u_114 = v_u_103
        end

        function v185()
            local v_u_110 = RaycastParams.new()
            v_u_110.FilterType = Enum.RaycastFilterType.Exclude
            local v_u_111 = { v_u_56, p_u_51, v_u_18, aimignoreparts}
            v_u_110.FilterDescendantsInstances = v_u_111
            v_u_110.CollisionGroup = "WeaponRay"
            v_u_110.IgnoreWater = true

            v_u_106 += 1

            local usethisvec = v_u_114
            if aimdebug1 then
                usethisvec = Vector3.new(0,1,0)
            end

            if v_u_106 == 1 then
                task.spawn(function()
                    for i=1, BurstFire do
                        if aimtype == "Instant Hit" then
                            if not v_u_7:InvokeServer(usethisvec, v_u_108, tick()-15) then 
                                game.ReplicatedStorage.Modules.FPS.Binds.AdjustBullets:Fire(v_u_64, 1)
                            end
                        else
                            if not v_u_7:InvokeServer(usethisvec, v_u_108, tick()) then 
                                game.ReplicatedStorage.Modules.FPS.Binds.AdjustBullets:Fire(v_u_64, 1)
                            end
                        end
                    end
                end)
            elseif 1 < v_u_106 then
                for i=1, BurstFire do
                    v_u_6:FireServer(usethisvec, v_u_108)
                end
            end

            local v_u_131 = nil
            local v_u_132 = 0
            local v_u_133 = 0

            if (aimtype == "Prediction" or aimfakewait) and target ~= nil then
                local tpart 
                if target:IsA("Model") then
                    tpart = target.HumanoidRootPart
                else
                    tpart = target.Character.HumanoidRootPart
                end
                local velocity = tpart.Velocity
                local distance = (wcamera.CFrame.Position - tpart.CFrame.Position).Magnitude
                local tth = (distance / bulletspeed)
                task.wait(tth + 0.01)

                if aimtarget ~= nil and aimtargetpart ~= nil then
                    target_part = aimtargetpart
                    if aimtype == "Prediction" then
                        local buldrop = v65:GetAttribute("ProjectileDrop")
                        local bulsp = v65:GetAttribute("MuzzleVelocity")
                        target_part = predictpos(target_part, bulsp, buldrop)
                        v_u_103 = CFrame.new(v_u_115, target_part).LookVector
                    else
                        v_u_103 = CFrame.new(v_u_115, target_part.Position).LookVector
                    end
                    v_u_114 = v_u_103
                else
                    target_part = p55
                    v_u_103 = CFrame.new(v_u_115, v_u_15:GetMouse().Hit.Position).LookVector
                    v_u_114 = v_u_103
                end
            end

            function v184(p134)
                v_u_132 = v_u_132 + p134
                if true then
                    v_u_133 = v_u_133 + v_u_132
                    local v136 = workspace:Raycast(v_u_115, v_u_114 * v135, v_u_110)
                    local v137 = nil
                    local v138 = nil
                    local v139 = nil
                    local v140
                    if v136 then
                        v137 = v136.Instance
                        v140 = v136.Position
                        v138 = v136.Normal
                        v139 = v136.Material
                    else
                        v140 = v_u_115 + v_u_114 * v135
                    end

                    if v137 == nil then
                        v_u_131:Disconnect()
                        return
                    end

                    tracerendpos = v140

                    local v171 = v_u_4:FindDeepAncestor(v137, "Model")
                    if v171:FindFirstChild("Humanoid") then -- if hit target
                        local ran = math.random(1, 100)
                        local ranbool = ran <= aimchance
                        if ranbool then
                            local v175 = v137.CFrame:ToObjectSpace(CFrame.new(v140))

                            if target_part then
                                v_u_5:FireServer(target_part, v175, v_u_108, tick())
                            else
                                v_u_5:FireServer(v137, v175, v_u_108, tick())
                            end
                        else
                            local v175 = v137.CFrame:ToObjectSpace(CFrame.new(v140))
                            v_u_5:FireServer(p55, v175, v_u_108, tick())
                        end

                        v_u_2.Impact(v137, v140, v138, v139, v_u_114, "Ranged", true)
                    elseif v137.Name == "Terrain" then -- if hit terrain
                        local v175 = v137.CFrame:ToObjectSpace(CFrame.new(v140))
                        v_u_5:FireServer(v137, v175, v_u_108, tick())

                        v_u_2.Impact(v137, v140, v138, v139, v_u_114, "Ranged", true)
                    else -- if hit not target then try wallbang
                        v_u_2.Impact(v137, v140, v138, v139, v_u_114, "Ranged", true)

                        local arg1, arg2, arg3 = v_u_4.Penetration(v_u_4, v137, v140, v_u_114, armorpen4)
                        if arg1 == nil or arg2 == nil then
                            v_u_131:Disconnect()
                            return
                        end

                        armorpen4 = arg1
                        if armorpen4 > 0 then
                            v_u_115 = arg2
                            v_u_2.Impact(unpack(arg3))
                            return
                        end

                        v_u_131:Disconnect()
                        return

                        --[[
                        if target_part ~= nil and target ~= nil then --wallbang
                            --[[
                            local bangparams = RaycastParams.new()
                            bangparams.FilterType = Enum.RaycastFilterType.Include
                            bangparams.FilterDescendantsInstances = {bangtarget}
                            bangparams.CollisionGroup = "WeaponRay" 
                            bangparams.IgnoreWater = true
                            --

                            local banglist = v_u_111
                            table.insert(banglist, v137)
                            v_u_110.FilterDescendantsInstances = banglist

                            --[[
                            local bangray = workspace:Raycast(v_u_115, v_u_114 * 123123123, v_u_110)
                            if bangray then
                                local plrmodel = v_u_4:FindDeepAncestor(bangray.Instance, "Model")

                                local fake175 = bangray.Instance.CFrame:ToObjectSpace(CFrame.new(v60.Position))
                                v_u_5:FireServer(bangray.Instance, fake175, v_u_108 + 1, tick() + 2)

                                task.spawn(function()
                                    if tracbool == true then
                                        runtracer(v60.Position, bangray.Position)
                                    end
                                end)
                            end
                            --
                        else --no wallbang 
                            local ran = math.random(1, 100)
                            local ranbool = ran <= aimchance
                            if ranbool then
                                local v175 = v137.CFrame:ToObjectSpace(CFrame.new(v140))
                                v_u_5:FireServer(v137, v175, v_u_108, tick())
                            else
                                local v175 = v137.CFrame:ToObjectSpace(CFrame.new(v140))
                                v_u_5:FireServer(p55, v175, v_u_108, tick())
                            end
                            v_u_2.Impact(v137, v140, v138, v139, v_u_114, "Ranged", true)
                        end
                        ]]
                    end
                end

                v_u_131:Disconnect()
                return
            end
            v_u_131 = game:GetService("RunService").RenderStepped:Connect(v184)
            return
        end
        if v_u_74 == nil then
            task.spawn(v185)
        else
            for _ = 1, v_u_74 do
                task.spawn(v185)
            end
        end

        if tracbool then
            task.spawn(function()
                task.wait(0.05)
                if tracerendpos == Vector3.zero then return end
                runtracer(v60.Position, tracerendpos)
            end)
        end

        return v83, v82, v81, v79
    end
end

--nosway

do
    local mod = require(game.ReplicatedStorage.Modules.FPS)
    local ogfunc = mod.updateClient

    mod.updateClient = function(a1,a2,a3)
        arg1, arg2, arg3 = ogfunc(a1,a2,a3)
        
        if NoSway then
            a1.springs.sway.Speed = 0
            a1.springs.walkCycle.Speed = 0
            a1.springs.sprintCycle.Speed = 0
            a1.springs.strafeTilt.Speed = 0
            a1.springs.jumpTilt.Speed = 0
        else
            a1.springs.sway.Speed = 4
            a1.springs.walkCycle.Speed = 4
            a1.springs.sprintCycle.Speed = 4
            a1.springs.strafeTilt.Speed = 4
            a1.springs.jumpTilt.Speed = 4
        end

        return arg1, arg2, arg3
    end
end

--instantequip

workspace.Camera.ChildAdded:Connect(function(ch)
    if InstaEquip and ch:IsA("Model") then
        task.wait(0.015)
        for i,v in ch.Humanoid.Animator:GetPlayingAnimationTracks() do
            if v.Animation.Name == "Equip" then
                --v:AdjustSpeed(15)
                v.TimePosition = v.Length - 0.01
            end
        end
    end
end)

--hitsounds
localplayer.CharacterAdded:Connect(function(lchar)
    local maingui = localplayer.PlayerGui:WaitForChild("MainGui")
    if maingui then
        maingui.ChildAdded:Connect(function(Sound)
            if Sound:IsA("Sound") and hitsoundbool then
                if Sound.SoundId == "rbxassetid://4585351098" or Sound.SoundId == "rbxassetid://4585382589" then --headshot
                    Sound.SoundId = hitsoundlib[hitsoundhead]
                elseif Sound.SoundId == "rbxassetid://4585382046" or Sound.SoundId == "rbxassetid://4585364605" then --bodyshot
                    Sound.SoundId = hitsoundlib[hitsoundbody]
                end
            end
        end)
    end
end)
localplayer.PlayerGui.MainGui.ChildAdded:Connect(function(Sound)
    if Sound:IsA("Sound") and hitsoundbool then
        if Sound.SoundId == "rbxassetid://4585351098" or Sound.SoundId == "rbxassetid://4585382589" then --headshot
            Sound.SoundId = hitsoundlib[hitsoundhead]
        elseif Sound.SoundId == "rbxassetid://4585382046" or Sound.SoundId == "rbxassetid://4585364605" then --bodyshot
            Sound.SoundId = hitsoundlib[hitsoundbody]
        end
    end
end)

--esp--

local function setupesp(obj, dtype, otype1)
    local dobj
    local tableinfo
    if dtype == "Name" then
        dobj = Drawing.new("Text")
        dobj.Visible = espbool
        dobj.Center = true
        dobj.Outline = true
        dobj.Size = esptextsize
        dobj.Color = esptextcolor
        dobj.OutlineColor = Color3.new(0, 0, 0)
        tableinfo = {
            primary = obj,
            type = "Name",
            otype = otype1
        }
    elseif dtype == "HP" then
        dobj = Drawing.new("Text")
        dobj.Visible = espbool
        dobj.Center = true
        dobj.Outline = true
        dobj.Size = esptextsize
        dobj.Color = esptextcolor
        dobj.OutlineColor = Color3.new(0, 0, 0)
        tableinfo = {
            primary = obj,
            type = "HP",
            otype = otype1
        }
    elseif dtype == "Distance" then
        dobj = Drawing.new("Text")
        dobj.Visible = espbool
        dobj.Center = true
        dobj.Outline = true
        dobj.Size = esptextsize
        dobj.Color = esptextcolor
        dobj.OutlineColor = Color3.new(0, 0, 0)
        tableinfo = {
            primary = obj,
            type = "Distance",
            otype = otype1
        }
    elseif dtype == "Hotbar" then
        dobj = Drawing.new("Text")
        dobj.Visible = espbool
        dobj.Center = true
        dobj.Outline = true
        dobj.Size = esptextsize
        dobj.Color = esptextcolor
        dobj.OutlineColor = Color3.new(0, 0, 0)
        tableinfo = {
            primary = obj,
            type = "Hotbar",
            otype = otype1
        }
    elseif dtype == "Highlight" then
        dobj = Instance.new("Highlight")
        dobj.Name = math.random(10,100)
        dobj.FillColor = espfillcolor
        dobj.OutlineColor = esplinecolor
        dobj.FillTransparency = espchamsfill
        dobj.OutlineTransparency = espchamsline
        if obj.Parent:IsA("Model") then
            dobj.Parent = obj.Parent
        else
            dobj:Destroy()
            return
        end

        dobj.Enabled = esphigh
        tableinfo = {
            primary = obj,
            type = "Highlight",
            otype = otype1
        }
    end

    if dobj == nil or tableinfo == nil then return end

    local function sd()
        if dtype == "Highlight" then
            dobj.Enabled = false
            dobj:Destroy()
        else
            dobj.Visible = false
            dobj:Destroy() -- Use :Destroy() instead of :Remove()
        end
        if removing then
            removing:Disconnect()
            removing = nil
        end
        return
    end


    if esptable[dobj] ~= nil then
        sd()
        return
    else
        esptable[dobj] = tableinfo
    end

    removing = workspace.DescendantRemoving:Connect(function(what)
        if what == obj then
            esptable[dobj] = nil
            sd()
        end
    end)
end
local function startesp(v, otype)
    task.spawn(function()
        if otype == "Extract" then
            setupesp(v, "Name", otype)
            setupesp(v, "Distance", otype)
        elseif otype == "Loot" then
            local Amount
            local TotalPrice = 0
            local Value = 0

            if v.Parent and v.Parent:FindFirstChild("Inventory") then else
                return
            end

            for _, i in ipairs(v.Parent.Inventory:GetChildren()) do
                Amount = i.ItemProperties:GetAttribute("Amount") or 1
                TotalPrice += i.ItemProperties:GetAttribute("Price") or 0
                Value += (valcache[i.ItemProperties:GetAttribute("CallSign")] or 0) * Amount
            end

            if Value >= 4 then
                setupesp(v, "Name", otype)
                setupesp(v, "Hotbar", otype)
                setupesp(v, "Distance", otype)
            end
        elseif otype == "Dead333" then
            local hd = v:WaitForChild("Head",1)
            if hd == nil then return end
            setupesp(hd, "Name", otype)
            setupesp(hd, "Distance", otype)
        else
            local hd = v:WaitForChild("Head",1)
            if hd == nil then return end
            setupesp(hd, "Name", otype)
            setupesp(hd, "HP", otype)
            setupesp(hd, "Distance", otype)
            setupesp(hd, "Hotbar", otype)
            setupesp(hd, "Highlight", otype) 
        end
    end)
end
for i,v in ipairs(workspace:GetDescendants()) do
    if v and v:FindFirstChild("Humanoid") and v ~= localplayer.Character then
        if game.Players:FindFirstChild(v.Name) and not v:FindFirstAncestor("DroppedItems") then
            startesp(v, "Plr")
        elseif v:FindFirstAncestor("AiZones") then
            startesp(v, "Bot333")
        elseif v:FindFirstAncestor("DroppedItems") then
            startesp(v, "Dead333")
        end
    elseif v.Parent == workspace:FindFirstChild("NoCollision"):FindFirstChild("ExitLocations") then
        startesp(v, "Extract")
    elseif v:FindFirstAncestor("Containers") and v:IsA("MeshPart") then
        if v.Parent:IsA("Model") then
            startesp(v, "Loot")
        end
    end
end
workspace.DescendantAdded:Connect(function(v)
    if v and v.Parent and v:IsA("BasePart") and v.Name == "Head" then
        local hum = v.Parent:WaitForChild("Humanoid", 2)
        if hum and v.Parent ~= localplayer.Character then
            if game.Players:FindFirstChild(v.Parent.Name) and not v:FindFirstAncestor("DroppedItems") then
                startesp(v.Parent, "Plr")
            elseif v:FindFirstAncestor("AiZones") then
                startesp(v.Parent, "Bot333")
            elseif v:FindFirstAncestor("DroppedItems") then
                startesp(v.Parent, "Dead333")
            end
        end
    elseif v.Parent == workspace:FindFirstChild("NoCollision"):FindFirstChild("ExitLocations") then
        startesp(v, "Extract")
    elseif v:FindFirstAncestor("Containers") and v:IsA("MeshPart") then
        if v.Parent:IsA("Model") then
            startesp(v, "Loot")
        end
    end
end)

--fullbright--

if worldvisualstoggle then
    pcall(function()
        local lighting = game:GetService("Lighting")
        lighting.Ambient = worldambient
        lighting.OutdoorAmbient = worldoutdoor
        lighting.Brightness = 1
        lighting.FogEnd = 100000
        lighting.GlobalShadows = false
        
        for _, v in pairs(lighting:GetDescendants()) do
            if v:IsA("Atmosphere") then
                v:Destroy()
            end
        end
        
        for _, v in pairs(lighting:GetDescendants()) do
            if v:IsA("BloomEffect") or v:IsA("BlurEffect") or v:IsA("ColorCorrectionEffect") or v:IsA("SunRaysEffect") then
                v.Enabled = false
            end
        end
        
        lighting.Changed:Connect(function()
            lighting.Ambient = worldambient
            lighting.Brightness = 1
            lighting.FogEnd = 100000
            lighting.OutdoorAmbient = worldoutdoor
            lighting.ClockTime = worldclock
            
            for _, v in pairs(lighting:GetChildren()) do
                if v:IsA("Atmosphere") then
                    v:Destroy()
                end
            end
        end)
        
        spawn(function()
            local character = localplayer.Character
            while wait(0.1) do
                repeat wait(0.1) until character ~= nil
                if not character.HumanoidRootPart:FindFirstChildWhichIsA("PointLight") then
                    local headlight = Instance.new("PointLight", character.HumanoidRootPart)
                    headlight.Brightness = 1
                    headlight.Range = 60
                end
            end
        end)
    end)
end


--inventory checker--

local function inventoryCheckerFrame()
	local BackgroundColor = Color3.fromRGB(30, 30, 30)
	local BorderColor = Color3.fromRGB(255, 255, 255)
	local TextColor = Color3.fromRGB(255, 255, 255)

	local MainFrame = sg:FindFirstChild("InventoryCheckerFrame") or Instance.new("Frame", sg)
	MainFrame.Name = "InventoryCheckerFrame"
	MainFrame.BackgroundColor3 = BackgroundColor
	MainFrame.BackgroundTransparency = 1
	MainFrame.AnchorPoint = Vector2.new(0.5, 0.5)
	MainFrame.BorderColor3 = BorderColor
	MainFrame.BorderSizePixel = 1
	MainFrame.Position = UDim2.fromScale(0.5, 0.15)
	MainFrame.Size = UDim2.fromScale(0.575, 0.18)

	local GridHolder = Instance.new("Frame", MainFrame)
	GridHolder.Name = "GridHolder"
	GridHolder.BackgroundColor3 = Color3.fromRGB(33, 33, 33)
	GridHolder.BorderColor3 = Color3.fromRGB(0, 0, 0)
	GridHolder.BorderSizePixel = 0
	GridHolder.Position = UDim2.new(0, 0, 0.314, 0)
	GridHolder.Size = UDim2.new(1, 0, 0.5, 0)

	local UICornerGridHolder = Instance.new("UICorner", GridHolder)
	UICornerGridHolder.CornerRadius = UDim.new(0, 0.5)

	local StrokeGridHolder = Instance.new("UIStroke", GridHolder)
	StrokeGridHolder.Thickness = 2
	StrokeGridHolder.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
	StrokeGridHolder.Color = Color3.fromRGB(255, 255, 255)
	local GridHolderGradient = Instance.new("UIGradient", StrokeGridHolder)
	GridHolderGradient.Color = ColorSequence.new{
		ColorSequenceKeypoint.new(0.00, Color3.fromRGB(0, 145, 255)),
		ColorSequenceKeypoint.new(1.00, Color3.fromRGB(0, 86, 161))
	}
	
	local GridHolderElement = Instance.new("UIGridLayout", GridHolder)
	GridHolderElement.Name = "GridHolderElement"
	GridHolderElement.SortOrder = Enum.SortOrder.LayoutOrder
	GridHolderElement.CellPadding = UDim2.new(0, 7, 0, 7)
	GridHolderElement.CellSize = UDim2.new(0, 51, 0, 51)

	local NameFrame = Instance.new("Frame", MainFrame)
	NameFrame.Name = "NameFrame"
	NameFrame.BackgroundColor3 = Color3.fromRGB(33, 33, 33)
	NameFrame.BorderColor3 = Color3.fromRGB(0, 0, 0)
	NameFrame.BorderSizePixel = 0
	NameFrame.Position = UDim2.new(0, 0, 0, 0)
	NameFrame.Size = UDim2.new(1, 0, 0.25, 0)

	local UICornerNameFrame = Instance.new("UICorner", NameFrame)
	UICornerNameFrame.CornerRadius = UDim.new(0, 0.5)

	local StrokeNameFrame = Instance.new("UIStroke", NameFrame)
	StrokeNameFrame.Thickness = 2
	StrokeNameFrame.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
	StrokeNameFrame.Color = Color3.fromRGB(255, 255, 255)
	local NameFrameGradient = Instance.new("UIGradient", StrokeNameFrame)
	NameFrameGradient.Color = ColorSequence.new{
		ColorSequenceKeypoint.new(0.00, Color3.fromRGB(0, 145, 255)),
		ColorSequenceKeypoint.new(1.00, Color3.fromRGB(0, 86, 161))
	}

	local TextLabel = Instance.new("TextLabel", NameFrame)
	TextLabel.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	TextLabel.BackgroundTransparency = 1.0
	TextLabel.Position = UDim2.new(0, 0, 0.169, 0)
	TextLabel.Size = UDim2.new(1, 0, 0.5, 0)
	TextLabel.Font = Enum.Font.Ubuntu
	TextLabel.Text = "N/A"
	TextLabel.TextColor3 = TextColor
	TextLabel.TextScaled = true
	TextLabel.TextSize = 14
	TextLabel.TextStrokeTransparency = 0.7
	TextLabel.TextWrapped = true

	local TextLabelGradient = Instance.new("UIGradient", TextLabel)
	TextLabelGradient.Color = ColorSequence.new{
		ColorSequenceKeypoint.new(0.00, Color3.fromRGB(0, 145, 255)),
		ColorSequenceKeypoint.new(1.00, Color3.fromRGB(0, 86, 161))
	}

	local FooterLabel = Instance.new("TextLabel", MainFrame)
	FooterLabel.BackgroundColor3 = Color3.fromRGB(255, 255, 255)
	FooterLabel.BackgroundTransparency = 1.0
	FooterLabel.Position = UDim2.new(0, 0, 1.046, 0)
	FooterLabel.Size = UDim2.new(0, 178, 0, 17)
	FooterLabel.Font = Enum.Font.Ubuntu
	FooterLabel.Text = "Exothium.xyz"
	FooterLabel.TextColor3 = TextColor
	FooterLabel.TextSize = 14
	FooterLabel.TextStrokeTransparency = 0.7
	FooterLabel.TextXAlignment = Enum.TextXAlignment.Left

	local FooterLabelGradient = Instance.new("UIGradient", FooterLabel)
	FooterLabelGradient.Color = ColorSequence.new{
		ColorSequenceKeypoint.new(0.00, Color3.fromRGB(0, 145, 255)),
		ColorSequenceKeypoint.new(1.00, Color3.fromRGB(0, 86, 161))
	}

	if not table.find(createdThings, MainFrame) then
		table.insert(createdThings, MainFrame)
	end

	return MainFrame, GridHolder, TextLabel
end

local Debounce = false
local closestDistance = math.huge
local closestPlayerTemp

local MainFrame, GridHolder, TextLabel

local function inventoryChecker()
    MainFrame, GridHolder, TextLabel = inventoryCheckerFrame()

    while inventoryCheckerToggle do
        task.wait()
        closestDistance = math.huge
        closestPlayerTemp = nil

        for _, player in ipairs(game.Players:GetPlayers()) do
            if player ~= localplayer and player.Character and player.Character.PrimaryPart then
                local part = player.Character.PrimaryPart
                local vector, onscreen = wcamera:WorldToScreenPoint(part.Position)
                local screenpoint = Vector2.new(vector.X, vector.Y)
                local mousePos = Vector2.new(mouse.X, mouse.Y)
                local distance = (screenpoint - mousePos).Magnitude

                if onscreen and distance < aimfov and distance < closestDistance then
                    closestDistance = distance
                    closestPlayerTemp = player
                end
            end
        end

        if closestPlayerTemp then
            if not Debounce then
                MainFrame.Visible = true
                Debounce = true

                if rp:FindFirstChild("Players") and rp.Players:FindFirstChild(closestPlayerTemp.Name) then
                    for _, f in ipairs(rp.Players[closestPlayerTemp.Name]:GetChildren()) do
                        if f:IsA("Folder") and f.Name ~= "Vault" then
                            for i, v in ipairs(f:GetChildren()) do
                                if v:FindFirstChild("ItemProperties") and v.ItemProperties:FindFirstChild("ItemIcon") and not GridHolder:FindFirstChild(v.Name .. i) then
                                    local imgLabel = Instance.new("ImageLabel", GridHolder)
                                    imgLabel.Name = v.Name .. i
                                    imgLabel.BackgroundTransparency = 1
                                    imgLabel.Image = v.ItemProperties.ItemIcon.Image
                                    TextLabel.Text = closestPlayerTemp.Name
                                end
                            end
                        end
                    end
                end
            end
        else
            MainFrame.Visible = false
            Debounce = false

            for _, img in pairs(GridHolder:GetChildren()) do
                if img:IsA("ImageLabel") then
                    img:Destroy()
                end
            end
        end
    end
end

local function onInventoryCheckerPressed(input)
    if input.KeyCode == inventoryCheckerBind then
        inventoryChecker()
    end
end

local function onInventoryCheckerReleased(input)
    if input.KeyCode == inventoryCheckerBind then
        MainFrame.Visible = false
    end
end

uis.InputBegan:Connect(onInventoryCheckerPressed)
uis.InputEnded:Connect(onInventoryCheckerReleased)

-- anti aim

function FlipBack()
    local characterxx = localplayer.Character or localplayer.CharacterAdded:Wait()
    local humanoidRootPart = characterxx:WaitForChild("HumanoidRootPart")
    local rootCFrame = humanoidRootPart.CFrame
    local position = rootCFrame.Position
    local forcedRotation = CFrame.Angles(math.rad(0), 0, 0)
    
    localplayer.Character.Humanoid.PlatformStand = true
    humanoidRootPart.CFrame = CFrame.new(position) * forcedRotation
end

-- ping

for i = 10, 1000, 10 do
    selftrack_data[i] = localplayer.Character.Head.Position
end
local function updateselfpos()
    for time = 990, 10, -10 do
        selftrack_data[time + 10] = selftrack_data[time]
    end
    selftrack_data[10] = localplayer.Character.Head.Position
end

-- resolver

spawn(function()
    while resolver do
        for _, player in ipairs(Players:GetPlayers()) do
            if player ~= localplayer then
                local character = player.Character
                if character then
                    local humanoid = character:FindFirstChildOfClass("Humanoid")
                    if humanoid then
                        local animator = humanoid:FindFirstChildOfClass("Animator")
                        if animator then
                            for _, track in ipairs(animator:GetPlayingAnimationTracks()) do
                                track:Stop()
                            end
                        end
                    end
                end
            end
        end
        wait(0.02)
    end
end)



--fly--

local function fly_move(dir)
    local hrp = localplayer.Character:FindFirstChild("HumanoidRootPart")
    if not hrp then return end

	local newPos = hrp.CFrame + (dir * 1)
	hrp.CFrame = newPos
end
local function fly_getclosestpoint()
    local hrp = localplayer.Character:FindFirstChild("HumanoidRootPart")
    if not hrp then return end

	local dirs = {
        Vector3.new(1, 0, 0),
        Vector3.new(-1, 0, 0),
        Vector3.new(0, 1, 0),
        Vector3.new(0, -1, 0),
        Vector3.new(0, 0, 1),
        Vector3.new(0, 0, -1),
        Vector3.new(1, 1, 0),
        Vector3.new(1, -1, 0),
        Vector3.new(-1, 1, 0),
        Vector3.new(-1, -1, 0),
        Vector3.new(1, 0, 1),
        Vector3.new(1, 0, -1),
        Vector3.new(-1, 0, 1),
        Vector3.new(-1, 0, -1),
        Vector3.new(0, 1, 1),
        Vector3.new(0, 1, -1),
        Vector3.new(0, -1, 1),
        Vector3.new(0, -1, -1),
        Vector3.new(1, 1, 1),
        Vector3.new(1, 1, -1),
        Vector3.new(1, -1, 1),
        Vector3.new(1, -1, -1),
        Vector3.new(-1, 1, 1),
        Vector3.new(-1, 1, -1),
        Vector3.new(-1, -1, 1),
        Vector3.new(-1, -1, -1)
    }

	local fcp = nil
	local cd = math.huge

    local playerslist = game.Players:GetPlayers()
    local ignorl = {localplayer.Character, wcamera}

    for _, player in ipairs(playerslist) do
        if player.Character then
            table.insert(ignorl, player.Character)
        end
    end

	for _, dir in ipairs(dirs) do
		local ray = Ray.new(hrp.Position, dir * 200)
		local part, pos = workspace:FindPartOnRayWithIgnoreList(ray, ignorl)
		if part and pos then
			local d = (hrp.Position - pos).Magnitude
			if d < cd then
				cd = d
				fcp = pos
			end
		end
	end

	return fcp
end
function fly_getoffset(dir)
	local offset = Vector3.new(0.1, 0.1, 0.1)
	if dir.X > 0 then
		offset = Vector3.new(0.1, 0, 0)
	elseif dir.X < 0 then
		offset = Vector3.new(-0.1, 0, 0)
	elseif dir.Y > 0 then
		offset = Vector3.new(0, 0.1, 0)
	elseif dir.Y < 0 then
		offset = Vector3.new(0, -0.1, 0)
	elseif dir.Z > 0 then
		offset = Vector3.new(0, 0, 0.1)
	elseif dir.Z < 0 then
		offset = Vector3.new(0, 0, -0.1)
	end
	return offset
end

-- admin detector --

local function CheckAdminStatus(player)
    local replicatedPlayers = rp:FindFirstChild("Players")
    if replicatedPlayers then
        local playerData = replicatedPlayers:FindFirstChild(player.Name)
        if playerData then
            local status = playerData:FindFirstChild("Status")
            if status then
                local UAC = status:FindFirstChild("UAC")
                if UAC then
                    return UAC:GetAttribute("A1Detected") or UAC:GetAttribute("A2Detected")
                end
            end
        end
    end
    return false
end

task.spawn(function()
    while true do
        for _, player in ipairs(Players:GetPlayers()) do
            local isAdmin = CheckAdminStatus(player)
            if isAdmin and not detectedAdmins[player.Name] then
                detectedAdmins[player.Name] = true
                print("[EXOTHIUM.XYZ] Admin joined:" .. player.Name)
                library:SendNotification(("Admin Detected: " .. player.Name), 15)
            elseif not isAdmin and detectedAdmins[player.Name] then
                detectedAdmins[player.Name] = nil
            end
        end
        task.wait(1)
    end
end)

Players.PlayerAdded:Connect(function(player)
    task.delay(1, function()
        if CheckAdminStatus(player) then
            print("[EXOTHIUM.XYZ] Admin joined:" .. player.Name)
            library:SendNotification(("Admin Detected: " .. player.Name), 15)
            detectedAdmins[player.Name] = true
        end
    end)
end)

Players.PlayerRemoving:Connect(function(player)
    if detectedAdmins[player.Name] then
    print("[EXOTHIUM.XYZ] Admin left:" .. player.Name)
    library:SendNotification(("Admin Left: " .. player.Name), 15)
        detectedAdmins[player.Name] = nil
    end
end)

--global cycle--

task.spawn(function() -- very slow
    while wait(10.5) do
        table.clear(aimignoreparts)
        for i,v in ipairs(workspace:GetDescendants()) do
            if v:GetAttribute("PassThrough") then
                table.insert(aimignoreparts, v)
            end
        end
    end
end)

task.spawn(function() -- slow
    while wait(1) do

        local function handleFoliage()
            if workspace:FindFirstChild("SpawnerZones") then
                for i, v in ipairs(workspace.SpawnerZones.Foliage:GetDescendants()) do
                    if v:FindFirstChildOfClass("SurfaceAppearance") then
                        if worldleaves then
                            v.Transparency = 1
                        else
                            v.Transparency = 0
                        end
                    end
                end
            end
        end

        local function handleInventory()
            local x, y, z = viewmodX, viewmodY, viewmodZ
            local offset = CFrame.new(Vector3.new(tonumber(x), tonumber(y), tonumber(z)))
            if not offset then return end
            local inv = game.ReplicatedStorage.Players:FindFirstChild(localplayer.Name).Inventory
            if not inv then return end
            for i, v in ipairs(inv:GetChildren()) do
                local sett = require(v.SettingsModule)
                sett.weaponOffSet = offset
                if RapidFire then
                    sett.FireRate = 0.002
                end
                if UnlockFiremodes then
                    sett.FireModes = {"Auto", "Semi"}
                end
            end
        end

        local function handleViewModelHighlight()
            if viewmodhighlightchams and wcamera:FindFirstChild("ViewModel") then
                local vmhighlight = Instance.new("Highlight")
                vmhighlight.Parent = wcamera:FindFirstChild("ViewModel")
                vmhighlight.DepthMode = Enum.HighlightDepthMode.Occluded

                vmhighlight.FillColor = viewmodhighlightfillcolor
                vmhighlight.OutlineColor = viewmodhighlightoutlinecolor

                vmhighlight.FillTransparency = viewmodhighlightfilltransparency
                vmhighlight.OutlineTransparency = viewmodhighlightoutlinetransparency
            elseif viewmodhighlightchams == false and wcamera:FindFirstChild("ViewModel") and wcamera:FindFirstChild("ViewModel"):FindFirstAncestorWhichIsA("Highlight") then
                local temporaryhighlight = wcamera:FindFirstChild("ViewModel"):FindFirstChildWhichIsA("Highlight")
                temporaryhighlight:Destroy()
            end
        end

        local function handleViewModel()
            if viewmodbool and wcamera:FindFirstChild("ViewModel") then
                for _, obj in ipairs(wcamera.ViewModel:GetDescendants()) do
                    if obj:IsA("BasePart") then
                        if not obj:FindFirstAncestor("Item") then
                            local mb = obj:FindFirstChildOfClass("SurfaceAppearance")
                            if mb then
                                mb:Destroy()
                            end

                            obj.Color = viewmodhandcolor
                            obj.Material = viewmodhandmat
                        else
                            local mb = obj:FindFirstChildOfClass("SurfaceAppearance")
                            if mb then
                                mb:Destroy()
                            end

                            obj.Color = viewmodguncolor
                            obj.Material = viewmodgunmat
                        end
                    elseif obj:IsA("Model") and obj:FindFirstChild("LL") then
                        obj:Destroy()
                    end
                end
            end
        end

        handleFoliage()
        handleInventory()
        handleViewModel()
        handleViewModelHighlight()
    end
end)

runs.RenderStepped:Connect(function(delta) --  fast
    runs.RenderStepped:Wait()

    if charsemifly == false and localplayer.Character.Humanoid.PlatformStand == true then
        --print("Line 2189 - Toggled platformstand to false \\ charsemifly == false, localplayer.Character.Humanoid.PlatformStand == true")
        localplayer.Character.Humanoid.PlatformStand = false
    end
--[[
    if hitsounds_enabled and currenthitsound ~= "" then
        hitMarkers.BodyArmor.SoundId = currenthitsound
        hitMarkers.Bodyshot.SoundId = currenthitsound
        hitMarkers.Headshot.SoundId = currenthitsound
        hitMarkers.Helmet.SoundId = currenthitsound
        hitMarkers.Kill.SoundId = currenthitsound
    else
        hitMarkers.BodyArmor.SoundId = originalSounds.BodyArmor
        hitMarkers.Bodyshot.SoundId = originalSounds.Bodyshot
        hitMarkers.Headshot.SoundId = originalSounds.Headshot
        hitMarkers.Helmet.SoundId = originalSounds.Helmet
        hitMarkers.Kill.SoundId = originalSounds.Kill
    end
]]

    if charsemifly and charantiaim_underground then
        flipback = true
    elseif charsemifly == false and charantiaim_underground and flipback then
        localplayer.Character.Humanoid.PlatformStand = true
        FlipBack()
        localplayer.Character.Humanoid.PlatformStand = true
        flipback = false
    end

    local function flipCharacterUpsideDown()
        local characterxx = localplayer.Character or localplayer.CharacterAdded:Wait()
        local humanoidRootPart = characterxx:WaitForChild("HumanoidRootPart")
        local rootCFrame = humanoidRootPart.CFrame
        local position = rootCFrame.Position
        local forcedRotation = CFrame.Angles(math.rad(xrot), yrot, zrot)

        humanoidRootPart.CFrame = CFrame.new(position) * forcedRotation
    end

    local bodyparts = {
        "FaceHitBox",
        "Head",
        "HeadTopHitBox",
        "LeftFoot",
        "LeftHand",
        "LeftLowerArm",
        "LeftLowerLeg",
        "LeftUpperArm",
        "LowerTorso",
        "RightFoot",
        "RightLowerArm",
        "RightUpperArm"
    }

    local character = localplayer.Character or localplayer.CharacterAdded:Wait()
    local originalCollisions = {}

    local function enableNoclip(character)
        for _, partName in pairs(bodyparts) do
            local part = character:FindFirstChild(partName)
            if part then
                originalCollisions[partName] = part.CanCollide
                part.CanCollide = false
            end
        end
    end

    local function disableNoclip(character)
        for _, partName in pairs(bodyparts) do
            local part = character:FindFirstChild(partName)
            if part and originalCollisions[partName] ~= nil then
                part.CanCollide = originalCollisions[partName]
            end
        end
    end

    if charsemifly and charantiaim_underground then
        flipCharacterUpsideDown()
        enableNoclip(character)
    else
        disableNoclip(character)
    end

    if upangletoggle then
        game:GetService("ReplicatedStorage").Remotes.UpdateTilt:FireServer(upangleY)
    end

    if charsemifly and localplayer.Character then --semifly
        local hrp = localplayer.Character:FindFirstChild("HumanoidRootPart")
        if not hrp then return end
        local dir = Vector3.new(0, 0, 0)
        

		if uis:IsKeyDown(Enum.KeyCode.W) then
			dir += wcamera.CFrame.LookVector
		elseif uis:IsKeyDown(Enum.KeyCode.S) then
			dir -= wcamera.CFrame.LookVector
		end

		if uis:IsKeyDown(Enum.KeyCode.A) then
			dir -= wcamera.CFrame.RightVector
		elseif uis:IsKeyDown(Enum.KeyCode.D) then
			dir += wcamera.CFrame.RightVector
		end

		if uis:IsKeyDown(Enum.KeyCode.Space) then
			dir += Vector3.new(0, 1, 0)
		elseif uis:IsKeyDown(Enum.KeyCode.LeftShift) then
			dir -= Vector3.new(0, 1, 0)
		end

		local closest = fly_getclosestpoint()
		if closest then
			local d = (hrp.Position - closest).Magnitude
			if d > charsemiflydist then
				local ldir = (hrp.Position - closest).Unit * charsemiflydist
				local offset = fly_getoffset(ldir)
				hrp.CFrame = CFrame.new(closest + ldir - offset)
			else
				fly_move(dir * charsemiflyspeed * runs.RenderStepped:Wait())
			end
		else
			fly_move(dir * charsemiflyspeed * runs.RenderStepped:Wait())
		end
    end

    if changerbool and localplayer.Character ~= nil then -- humanoid changer
        localplayer.Character.Humanoid.WalkSpeed = changerspeed
        localplayer.Character.Humanoid.JumpHeight = changerjump
        localplayer.Character.Humanoid.HipHeight = changerheight
        workspace.Gravity = changergrav
    end

if aimtarget ~= nil then
    local displayText = "[[ " .. aimtarget.Name

    local botNames = {
        "Death",
        "Whisper",
        "Anton",
        "AntonGuard",
        "Dozer",
        "OccupantSniper",
        "SniperBandit",
        "OccupantSoldier",
        "OccupantSurveyTeam",
        "WastelandBandit",
        "HighwayBandit"
    }

    local isBot = false
    for _, botName in ipairs(botNames) do
        if aimtarget.Name == botName then
            isBot = true
            break
        end
    end

    local isAdmin = false
    if not isBot then
        local player = game:GetService("ReplicatedStorage").Players:FindFirstChild(aimtarget.Name)
        if player and player:FindFirstChild("Status") then
            local status = player.Status.UAC
            isAdmin = (status:GetAttribute("A1Detected") == true) or (status:GetAttribute("A2Detected") == true)
        end
    end

    if healthtargetname and not isBot and aimtarget.Character and aimtarget.Character:FindFirstChild("Humanoid") then
        displayText = displayText .. " | HP: " .. aimtarget.Character.Humanoid.Health
    end

    if admintargetname and not isBot then
        displayText = displayText .. " | Admin: " .. tostring(isAdmin)
    end

    displayText = displayText .. " ]]"
    aimtargetname.Text = displayText
else
    aimtargetname.Text = " "
end

    aimtargetname.Position = Vector2.new(wcamera.ViewportSize.X / 2, wcamera.ViewportSize.Y / 2 + aimfov + 20) 
    aimfovcircle.Position = Vector2.new(wcamera.ViewportSize.X / 2, wcamera.ViewportSize.Y / 2)
--[[
if aimtarget ~= nil then

    

    local character = aimtarget.Character
    local humanoid = character and character:FindFirstChildOfClass("Humanoid")
    
    if humanoid then
        local health = humanoid.Health
        local camera = workspace.CurrentCamera
        local screenPos, onScreen = camera:WorldToScreenPoint(character.PrimaryPart.Position)

        aimtargetname.Text = string.format(
            " %s | Health: %d ",
            aimtarget.Name, math.floor(health)
        )

        aimtargetname.Position = Vector2.new(screenPos.X, screenPos.Y)
    else
        aimtargetname.Text = " ".. aimtarget.Name .." | Health: N/A "
    end
else
    aimtargetname.Text = " "
end
]]

--[[
    if aimtarget ~= nil then --on screen stuff
        aimtargetname.Text = " ".. aimtarget.Name .." "
    else
        aimtargetname.Text = " "
    end
    ]]
    crosshair.Position = Vector2.new(wcamera.ViewportSize.X / 2, wcamera.ViewportSize.Y / 2)

    if aimdynamicfov then
        aimfovcircle.Radius = aimfov * (90 / wcamera.FieldOfView )
    else
        aimfovcircle.Radius = aimfov
    end

    selftrack_update += delta
    if selftrack_update >= 0.01 then
        updateselfpos(selftrack_update)
        selftrack_update = 0
    end

    if aimtrigger and aimtarget ~= nil then
        if not uis.MouseIconEnabled then
            task.spawn(function()
                mouse1press()
                wait()
                mouse1release()
            end)
        end
    end

    choosetarget() -- aim part

    if snaplinebool and aimtargetpart then
        aimsnapline.Visible = true
        local headpos = wcamera:WorldToViewportPoint(aimtargetpart.Position)
        aimsnapline.From = Vector2.new(wcamera.ViewportSize.X / 2, wcamera.ViewportSize.Y / 2)
        aimsnapline.To = Vector2.new(headpos.X, headpos.Y)
    else
        aimsnapline.Visible = false
    end

    for dobj, info in esptable do --esp part
        local dtype = info.type
        local otype = info.otype
        
        if info.primary == nil or info.primary.Parent == nil then
            esptable[dobj] = nil
            if dtype == "Highlight" then
                dobj.Enabled = false
                dobj:Destroy()
            else
                dobj.Visible = false
                dobj:Remove()
            end
            continue
        end

        local obj
        local isHumanoid
        if otype == "Extract" then
            obj = info.primary
            isHumanoid = true
        elseif otype == "Loot" then
            obj = info.primary
            isHumanoid = true
        else
            obj = info.primary.Parent:FindFirstChild("UpperTorso")
            if not obj then
                esptable[dobj] = nil
                if dtype == "Highlight" then
                    dobj.Enabled = false
                    dobj:Destroy()
                else
                    dobj.Visible = false
                    dobj:Remove()
                end
                continue
            end
            isHumanoid = obj.Parent:FindFirstChild("Humanoid")
        end

        if (otype == "Bot333" and espbots == false) or (otype == "Dead333" and espdead == false) or (otype == "Extract" and espexit == false) or (otype == "Loot" and esploot == false) then
            if dtype == "Highlight" then
                dobj.Enabled = false
            else
                dobj.Visible = false
            end
            continue
        end

        if localplayer.Character == nil or localplayer.Character.PrimaryPart == nil then
            if dtype == "Highlight" then
                dobj.Enabled = false
            else
                dobj.Visible = false
            end
            continue
        end
        
        if otype == "Bot333" and obj.Parent.Humanoid.Health == 0 then
            info.otype = "Dead333"
        end

        local metersdist = math.floor((localplayer.Character.PrimaryPart.Position - obj.Position).Magnitude * 0.333)

        if espbool and isonscreen(obj) and isHumanoid and metersdist < esprenderdist then
            local headpos = wcamera:WorldToViewportPoint(obj.Position)
            local resultpos = Vector2.new(headpos.X, headpos.Y)
    
            if dtype == "Name" then
                if espname then
                    resultpos = resultpos - Vector2.new(0, 15)
                    if otype == "Extract" then
                        dobj.Text = obj.Name
                    else
                        dobj.Text = obj.Parent.Name
                    end
                    dobj.Position = resultpos
                    dobj.Size = esptextsize
                    dobj.Color = esptextcolor
                    dobj.Outline = esptextline
                    dobj.Visible = true
                else
                    dobj.Visible = false
                end
            elseif dtype == "HP" then

                if otype == "Dead333" then
                    dobj.Visible = false
                    continue
                end

                resultpos = resultpos - Vector2.new(0, 30)
                dobj.Text = math.floor(obj.Parent.Humanoid.Health) .. "HP"
                dobj.Position = resultpos
                dobj.Size = esptextsize
                dobj.Color = esptextcolor
                dobj.Visible = esphp
                dobj.Outline = esptextline
            elseif dtype == "Distance" then
                if espdistance then
                    resultpos = resultpos - Vector2.new(0, 45)
                    dobj.Text = metersdist .. "m"
                    dobj.Position = resultpos
                    dobj.Size = esptextsize
                    dobj.Color = esptextcolor
                    dobj.Outline = esptextline
                    dobj.Visible = true
                else
                    dobj.Visible = false
                end
            elseif dtype == "Hotbar" then

                if otype == "Dead333" then
                    dobj.Visible = false
                    continue
                end

                resultpos = resultpos + Vector2.new(0, 15)
                local hotgun = "None"
                for _, v in ipairs(obj.Parent:GetChildren()) do
                    if v:FindFirstChild("ItemRoot") then
                        hotgun = v.Name
                        break
                    end
                end

                dobj.Visible = esphotbar
                if otype == "Loot" then
                    local Amount
                    local TotalPrice = 0
                    local Value = 0

                    for _, h in ipairs(obj.Parent.Inventory:GetChildren()) do
                        Amount = h.ItemProperties:GetAttribute("Amount") or 1
                        TotalPrice += h.ItemProperties:GetAttribute("Price") or 0
                        Value += (valcache[h.ItemProperties:GetAttribute("CallSign")] or 0) * Amount
                    end

                    if Value >= 20 then
                        dobj.Text = "Loot: $$$$ / " .. TotalPrice .. "$"
                    elseif Value >= 12 then
                        dobj.Text = "Loot: $$$ / " .. TotalPrice .. "$"
                    elseif Value >= 8 then
                        dobj.Text = "Loot: $$ / " .. TotalPrice .. "$"
                    elseif Value >= 4 then
                        dobj.Text = "Loot: $ / " .. TotalPrice .. "$"
                    end
                else
                    dobj.Text = hotgun
                end
                dobj.Position = resultpos
                dobj.Size = esptextsize
                dobj.Outline = esptextline
                dobj.Color = esptextcolor
            elseif dtype == "Highlight" then

                if otype == "Dead333" then
                    esptable[dobj] = nil
                    dobj.Enabled = false
                    dobj:Destroy()
                    continue
                end

                if obj.Parent == nil or not obj.Parent:IsA("Model") then
                    esptable[dobj] = nil
                    dobj.Enabled = false
                    dobj:Destroy()
                    continue
                end

                dobj.FillColor = espfillcolor
                dobj.OutlineColor = esplinecolor
                dobj.FillTransparency = espchamsfill
                dobj.OutlineTransparency = espchamsline
                dobj.Enabled = esphigh
            end
        else
            if dtype == "Highlight" then
                dobj.Enabled = false
            else
                dobj.Visible = false
            end
        end
    end
end)

local Time = (string.format("%."..tostring(Decimals).."f", os.clock() - Clock))
library:SendNotification(("Loaded in "..tostring(Time).."s"), 6)

movementtoggle(false); charsemifly = false

--[[
    --Window1:SetOpen(false)
    makefolder("Title Here")
    library:SetTheme(Default)
    library:GetConfig(Default)
    library:LoadConfig(Default)
    library:SaveConfig(Default)
]]
